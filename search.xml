<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux系统shadowsocksR客户端配置]]></title>
    <url>%2F2019%2F06%2F13%2Flinux%E7%B3%BB%E7%BB%9FshadowsocksR%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[测试]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssr</tag>
        <tag>shadowsocksR</tag>
        <tag>polipo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-解压文件]]></title>
    <url>%2F2017%2F11%2F22%2Flinux-%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文总结了Linux下解压文件的参数详解和指令。根据Linux下的tar压缩解压缩命令详解重新整理。 干货 参数 解释 *.tar 用 tar -xvf 解压 *.gz 用 gzip -d或者gunzip 解压 *.tar.gz 和 *.tgz 用 tar -xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2 用tar -xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar -xZf 解压 *.rar 用 unrar 解压 *.zip 用 unzip 解压 参数解释经常使用的指令为tar，主要有以下几个参数： 参数 解释 -t 查看内容 -c 建立压缩档案 -x 解压 -r 向压缩归档文件末尾追加文件 -u 更新原压缩包中的文件 这几个参数，只能独立使用，每次都会用到一个，但是不能混合使用。 下面这个几个参数可以联合使用： 参数 解释 -z 有gzip属性的 -j 有bz2属性的 -Z 有compress属性的 -v 显示所有过程 -O 将文件解开到标准输出 下面的参数-f是必须的 参数 解释 -f 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名 解压tar -xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar -xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 压缩tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并将其用gzip压缩，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并将其用bzip2压缩，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并将其用compress压缩，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux]]></content>
      <tags>
        <tag>linux</tag>
        <tag>解压</tag>
        <tag>tar</tag>
        <tag>zip</tag>
        <tag>gzip</tag>
        <tag>bz2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-后台运行]]></title>
    <url>%2F2017%2F11%2F02%2Flinux-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[很多时候我们希望在后台运行一些程序，方便我们查看，监控或者开启一些服务，但是如果是在终端中启动的程序，一旦终端被关闭，程序也就终止了，而且如果是给反馈的程序，我们的终端就需要一直开启，不能进行其他操作，如果需要进行其他操作，需要重新打开一个终端这样非常不便于远程ssh链接服务器进行操作。 干货不解释了，快上车！ screen -Smd &lt;name> &lt;command> #用就可以了，不要问为什么 nohup和&amp;语法：nohup &lt;程序&gt; &amp; &amp;在应用Unix/Linux时，我们一般想让某个程序在后台运行，于是我们将常会用 &amp; 在程序结尾来让程序自动运行。比如我们要运行mysql在后台： /usr/local/mysql/bin/mysqld_safe –user=mysql &amp;。 虽然可以进入后台，但是一旦退出终端，这个程序还是会被终止。 nohup如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思(no hang up)。还可以把一些具有输出的程序，输出内容重定向。 nohup /root/start.sh &amp;在shell中回车后提示： [~]$ appending output to nohup.out 原程序的的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用。即使退出终端，这个程序也依然在运行。 控制后台jobs #查看当前有多少在后台运行的命令 fg #将后台中的命令调至前台继续运行 bg #将一个在后台暂停的命令，变成继续执行 ctrl + z #可以将一个正在前台执行的命令放到后台，并且暂停 screen我们经常需要 SSH 或者 telent 远程登录到 Linux 服务器，为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。其实我们可以使用一个更为强大的实用程序screen。 创建screen 创建指令 解释 -c file 使用配置文件file，而不使用默认的$HOME/.screenrc -d -D [pid.tty.host] 不开启新的screen会话，而是断开其他正在运行的screen会话 -h num 指定历史回滚缓冲区大小为num行 -ls 列出现有screen会话，格式为pid.tty.host -dm 启动一个开始就处于断开模式的会话 -r [pid.tty.host] 重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限 -S &lt;name&gt; 创建screen会话时为会话指定一个名字 -v 显示screen版本信息 -wipe [match] 同-list，但删掉那些无法连接的会话 操作screen默认情况下，screen接收以C-a开始的命令。这种命令形式在screen中叫做键绑定（key binding），C-a叫做命令字符（command character）。 操作指令 解释 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口(与C-a n相对) C-a 0..9 切换到窗口0..9 C-a a 发送 C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式]]></content>
      <tags>
        <tag>linux</tag>
        <tag>screen</tag>
        <tag>守护进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell编程 ( )，(( ))，[ ]，[[ ]]，{ } 的作用]]></title>
    <url>%2F2017%2F06%2F23%2Fshell%E7%BC%96%E7%A8%8B()%2C(())%2C%5B%5D%2C%5B%5B%5D%5D%2C%7B%7D%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[第一次接触linux下shell脚本进行数学运算完全摸不到头脑。本问介绍shell下如何进行运算，其中还扩展出了一些其他的东西。 shell的运算在使用运算符时，需要注意到运算顺序的问题。例如输入下面的命令，输出1+2的结果。 echo 1+2 Shell并没有输出结果3，而是输出了1+2。在shell中有三种方法可以更改运算顺序。 用expr改变运算顺序。可以用echo &apos;expr 1 +2&apos; 来输出1+2的结果，用expr表示后面的表达式为一个数学运算。需要注意的是，&apos; 并不是一个单引号，而是“Tab”键上面的那个符号。 用let指示数学运算。可以先将运算的结果赋值给变量b，运算命令是b=let 1 + 2。然后用echo$b来输出b的值。如果没有let，则会输出1+2。 用$[ ]表示数学运算的值。将一个数学运算写到$[ ]符号的中括号中，中括号中的内容将先进行数学运算。例如命令echo $[1+2]，将输出结果3。也可以使用$(( ))。 ( ) 命令组：在括号中的命令列表, 将会作为一个子shell来运行。在括号中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的。父进程，也就是脚本本身，将不能够读取在子进程中创建的变量，也就是在子shell中创建的变量。(cmd1;cmd2;cmd3) 初始化数组Array=(element1 element2 element3) (( )) (( … ))结构可以用来计算并测试算术表达式的结果. 退出状态将会与[ … ]结构完全相反！还可应用到c风格的for，while循环语句，(( )) 中，所有的变量(加不加$无所谓)都是数值。$((…))结构的表达式是C风格的表达式，其返回的结果是表达式值，其中变量引用可不用‘$’(当然也可以）。 for((...;...;...)) do cmd done while ((...)) do cmd done 比较操作符小于：(($a &lt; $b))小于等于：(($a &lt;= $b))大于：(($a &gt; $b))大于等于：(($a &gt;= $b)) ps：如果要用echo输出出来，或者被其他变量调用，在前面要加$符号，比如 echo $((...)) 。 [ ]注意空格： 标识符，变量，运算符之间都是要有空格的！ bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。 Test和[ ]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。 [[ ]]注意空格： 标识符，变量，运算符之间都是要有空格的！ [[ ]] 结构比[ ]结构更加通用。在[[ ]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。 使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。例： if [[ $a != 1 &amp;&amp; $a != 2 ]] 如果不适用双括号，则为 if [ $a -ne 1] &amp;&amp; [ $a != 2 ] 或者 if [ $a -ne 1 -a $a != 2 ] ps：[[ ]]比[ ] 更好用。但是[ ]可以进行算术运算比较，$[ ]可以返回数学表达式的值。 { } 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与( )中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{ }的第一个命令和左括号之间必须要有一个空格。 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。 第一种：对大括号中的以逗号分割的文件列表进行拓展。 touch {a,b}.txt 结果为a.txt b.txt。 第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用或者使用[ - ]。 touch {a..d}.txt #等价于 touch [a-d].txt 结果为a.txt b.txt c.txt d.txt ${ } 它其实就是用来作变量替换用的。一般情况下，$var 与 ${var} 并没有啥不一样。但是用 ${ } 会比较精确的界定变量名称的范围。 #定义了变量为： file=/dir1/dir2/dir3/my.file.txt 1.我们可以用 ${ } 分别替换获得不同的值： ${file#*/} 拿掉第一条 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt ${file##*/} 拿掉最后一条 / 及其左边的字符串：my.file.txt ${file#*.} 拿掉第一个 . 及其左边的字符串：file.txt ${file##*.} 拿掉最后一个 . 及其左边的字符串：txt ${file%/*} 拿掉最后条 / 及其右边的字符串：/dir1/dir2/dir3 ${file%%/*} 拿掉第一条 / 及其右边的字符串：(空值) ${file%.*} 拿掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file ${file%%.*} 拿掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 记忆的方法为：#是去掉左边(在键盘上 # 在 $ 之左边)%是去掉右边(在键盘上 % 在 $ 之右边) 2.单一符号是最小匹配﹔两个符号是最大匹配： ${file:0:5} 提取最左边的 5 个字节：/dir1 ${file:5:5} 提取第 5 个字节右边的连续 5 个字节：/dir2 3.我们也可以对变量值里的字符串作替换： ${file/dir/path} 将第一个 dir 提换为 path：/path1/dir2/dir3/my.file.txt ${file//dir/path} 将全部 dir 提换为 path：/path1/path2/path3/my.file.txt 4.利用 ${ } 还可针对不同的变量状态赋值(没设定、空值、非空值)： ${file-my.file.txt} 假如 $file 没有设定，则使用 my.file.txt 作传回值。(空值及非空值时不作处理) ${file:-my.file.txt} 假如 $file 没有设定或为空值，则使用my.file.txt 作传回值。 (非空值时不作处理) ${file+my.file.txt} 假如 $file 设为空值或非空值，均使用my.file.txt 作传回值。(没设定时不作处理) ${file:+my.file.txt} 若 $file 为非空值，则使用 my.file.txt 作传回值。(没设定及空值时不作处理) ${file=my.file.txt} 若 $file 没设定，则使用 my.file.txt 作传回值， 同时将 $file 赋值为 my.file.txt 。(空值及非空值时不作处理) ${file:=my.file.txt} 若$file没设定或为空值，则使用my.file.txt作传回值， 同时将 $file 赋值为my.file.txt 。(非空值时不作处理) ${file?my.file.txt} 若 $file 没设定，则将 my.file.txt 输出至STDERR。(空值及非空值时不作处理) ${file:?my.file.txt} 若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。(非空值时不作处理) 以上的理解在于，你一定要分清楚 unset 与 null 及 non-null 这三种赋值状态。一般而言：: 与 null 有关，若不带 : 的话，null 不受影响，若带 : 则连null 也受影响。 5.可以用 ${#var} 计算出变量值的长度： ${#file} 可得到 27 ，因为 /dir1/dir2/dir3/my.file.txt 刚好是 27 个字节... ps:为了规范代码建议在使用变量时，统一用 { } 把变量包裹住。例如：${var} 总结()会开启一个新的子shell，{}不会开启一个新的子shell。 (())常用于算术运算比较,[[]]常用于字符串的比较。 $()返回括号中命令执行的结果。 $(())返回的结果是括号中表达式值。 $(())和$[]都可以进行数学运算且返回表达式的值。 ${ }参数替换与扩展。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github项目fork后同步更新]]></title>
    <url>%2F2017%2F06%2F14%2FGithub%E9%A1%B9%E7%9B%AEfork%E5%90%8E%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[fork 了别人的仓库后，原作者又更新了仓库，如何将自己的代码和原仓库保持一致？github上有个fork的选项，它会把你想参与的项目copy一份在你自己的仓库，但是要怎么进行和源的更新呢，下面将介绍fork项目后的更新。 一般我们fork项目后默认分支是master，为了方便代码管理我们会在自己的仓库里面创建一个分支branch，把这个分支branch设置成默认分支，再对这个分支进行修改。如果要贡献代码可以点击pull request，当原作者认可你的代码，他会把你的代码和项目代码进行merge，这样你就对项目进行了代码贡献。 但是如果在参与项目中，源项目已经进行了更新，我们可以先把master分支和源项目进行同步更新，然后再跳转到自己的分支branch上和master进行merge，这样自己fork的项目就可以保证是最新的。 部分内容转载自：https://gaohaoyang.github.io/2015/04/12/Syncing-a-fork/ 步骤给 fork 配置一个 remote 主要使用 git remote -v 查看远程状态。 git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 添加一个将被同步给 fork 远程的上游仓库 git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 再次查看状态确认是否配置成功。 git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Syncing a fork 从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/mastergit fetch upstream 可以把上游库的全部分支拉到本地来，但是无法打开或者查看，因为本地没有分支（容器）装载它们。 git fetch upstream > remote: Counting objects: 75, done. > remote: Compressing objects: 100% (53/53), done. > remote: Total 62 (delta 27), reused 44 (delta 9) > Unpacking objects: 100% (62/62), done. > From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY > * [new branch] master -> upstream/master 切换到本地主分支(如果不在的话)git checkout master git checkout master > Switched to branch 'master' 把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。git merge upstream/master git merge upstream/master > Updating a422352..5fdff0f > Fast-forward > README | 9 ------- > README.md | 7 ++++++ > 2 files changed, 7 insertions(+), 9 deletions(-) > delete mode 100644 README > create mode 100644 README.md 如果想更新到 GitHub 的 fork 上，直接 git push origin master 就好了。 备注：关于拉取某个分支到本地 先通过 git branch 来查看分支git branch -a 查看所有分支git branch -l 查看本地分支 把远程分支信息拉取到本地git fetch origin 把远程分支拉到本地 关联本地和远程分支git checkout -b dev origin/dev 在本地创建分支dev并切换到该分支且把本地分支和远程分支关联起来 最后使用：git pull origin dev 就可以把某个分支上的内容都拉取到本地了 参考 git checkout -b 本地分支名 origin/远程分支名使用该方式会在本地新建分支，并自动切换到该本地分支。 git fetch origin 远程分支名:本地分支名使用该方式会在本地新建分支x，但是不会自动切换到该本地分支，需要手动checkout。]]></content>
      <tags>
        <tag>git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2进行自动远程登录]]></title>
    <url>%2F2017%2F06%2F13%2FiTerm2%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Windows上有xshell可以进行远程主机管理，但是mac和linux上没有这种软件，我们可以采用脚本的方式进行登录。 设置自动远程登录也可以使用密钥进行登录，但本文采取的方案是expect脚本的方式。 不通过跳板机进行登录1、 写一个expect脚本 #!/usr/bin/expect set timeout 30 spawn [lindex $argv 0] [lindex $argv 1] expect { "(yes/no)?" {send "yes\n";exp_continue} "password:" {send "[lindex $argv 2]\n"} } interact 该脚本比较简单，需要三个参数，第一个参数是选择ssh连接还mosh连接，第二个参数是 用户名@远程地址，第三个参数是密码。 2、 将expect脚本copy到$PATH下（例如/usr/local/bin） 3、 在iterm2中设置登录命令为1中的脚本，用command+o的方式呼出profiles，点击Edit Profiles 如上图配好后，即可自动登录 跳板机进行登录下面再说下有跳板机的情况不同公司的环境不一样，也许某些同学可以进行参考 跳板机上不能存放任何文件，/tmp下可以方临时文件，每天会定时清掉。 copy文件方向只能是local-&gt;跳板机-&gt;remote的方向，即local可以push/pull跳板机上的文件，跳板机可以push/pull远程上的文件。 向跳板机登录前需要通过邮件/短信的方式获取passcode，这是除密码之外的额外的验证方式其实跳板机的自动远程登录与非跳板机的差异在expect脚本的编写上，其他的照搬即可，那这里就直接把代码贴出来就行了。 #!/usr/bin/expect # 参数1：远程host；参数2：远程password if { $argc != 2 } { send_user "Usage: host password\n" exit } set host [lindex $argv 0] set pw [lindex $argv 1] set TERMSERV yourjumpserver # 跳板机服务器 set USER jumpserveruser # 用户名 set PASSWORD jumperserverpasswd # 跳板机密码 set fd [open /place/to/passcode r] # 本地存放passcode的地方 gets $fd pc close $fd # Start the session catch {spawn ssh -l $USER $TERMSERV} # 登录跳板机 # Login expect "*assword:*" { send "$PASSWORD\r" } expect "*passcode:*" { send "$pc\r" } #通过跳板机登录线上机器 expect "*hostname*" { send "ssh -l $USER $host\r" } # hostname为你跳板机的名字 expect { "(yes/no)?" {send "yes\n";exp_continue} "*assword:*" {send "$pw\n"} } expect "*$host*" { send "cd ~\r"; interact }]]></content>
      <tags>
        <tag>mac</tag>
        <tag>iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置终端环境 iTerm2 + Zsh + Oh-My-Zsh + tmux]]></title>
    <url>%2F2017%2F06%2F13%2F%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83iTerm2-Zsh-Oh-My-Zsh-tmux%2F</url>
    <content type="text"><![CDATA[参考内容：http://www.tuicool.com/articles/FFN7Vbqhttps://zhuanlan.zhihu.com/p/19556676?columnSlug=mactalk mac电脑的终端自动补全很是有问题，现在可以使用zsh来进行终端操作。 iTerm2iTerm 2 is a terminal emulator for Mac OS X that does amazing things.iTerm2 是一个终端模拟器，官方网站： http://www.iterm2.com/ 修改主题后出现问题终端灰蒙蒙的，就像下面这样： 下面我们来回到彩色世界：依次打开 iTerm2 - Profiles - Edit Profiles - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉。 彩色的世界就回来了 有意思的配置 快捷键呼出 Preferences - Keys - Hotkey - Hotkey toggles a dedicated window with profile 把它设置成 Hotkey Window，按快捷键之后 Hotkey Window 会从屏幕上面折叠下来 菜单栏中的 Window 还有一些有趣的东西，比如保存读取窗口快照 Preferences - Profiles - Terminal - Terminal Emulation - Report Terminal Type 将其中的 xterm 改成 xterm-256color，比如在 Vim 显示一些配色方案会好很多 复用上个会话的目录 Preferences - Profiles - Working Directory - Reuse previous session’s directory 快捷键 ⌘ + Click ：可以打开文件，文件夹和链接 ⌘ + n ：新建窗口 ⌘ + t ：新建标签页 ⌘ + w ：关闭当前页 ⌘ + 数字 &amp; ⌘ + 方向键 ：切换标签页 ⌥⌘ + 数字 ：切换窗口 ⌘ + enter ：切换全屏 ⌘ + d ：左右分屏 ⇧⌘ + d ：上下分屏 ⌘ + ; ：自动补全历史记录 ⇧⌘ + h ：自动补全剪贴板历史 ⌥⌘ + e ：查找所有来定位某个标签页 ⌘ + r &amp; ⌃ + l ：清屏 ⌘ + / ：显示光标位置 ⌥⌘ + b ：历史回放 ⌘ + f ：查找，然后用 tab 和 ⇧ + tab 可以向右和向左补全，补全之后的内容会被自动复制， 还可以用 ⌥ + enter 将查找结果输入终端 选中即复制，鼠标中键粘贴 很多快捷键都是通用的，和 Emace 等都是一样的 ⌃ + u ：清空当前行 ⌃ + a ：移动到行首 ⌃ + e ：移动到行尾 ⌃ + f ：向前移动 ⌃ + b ：向后移动 ⌃ + p ：上一条命令 ⌃ + n ：下一条命令 ⌃ + r ：搜索历史命令 ⌃ + y ：召回最近用命令删除的文字 ⌃ + h ：删除光标之前的字符 ⌃ + d ：删除光标所指的字符 ⌃ + w ：删除光标之前的单词 ⌃ + k ：删除从光标到行尾的内容 ⌃ + t ：交换光标和之前的字符 还有鼠标和触摸板控制Preferences - Pointer zshShell是Linux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。 Linux/Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看： cat /etc/shells 显示如下： /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？ 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。 安装zshMac，执行：brew install zshRedhat Linux，执行：sudo yum install zshUbuntu Linux，执行：sudo apt-get install zsh 安装完成后设置当前用户使用 zsh ,执行：chsh -s /bin/zsh根据提示输入当前用户的密码就可以了。 注：brew 全称是 Homebrew ，可以安装 Apple 没有预装但你需要的东西。macOS 的软件包管理器。在终端运行/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装 Homebrew。 zsh使用 兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。 强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。 智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的…… 各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b 上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键 ，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键 ，zsh会列出所有访问过的主机和用户名进行补全。 智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录。通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全。例如你访问过hadoop-1.0.0目录，输入 j hado 即可正确跳转。j –stat 可以看你的历史路径库。 目录浏览和跳转：输入 d ，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 在当前目录下输入 .. ，或直接输入当前目录名都可以跳转，不再需要输入 cd 命令了。 通配符搜索：ls -l **/*.sh ，可以递归显示当前目录下的 shell 文件。文件少时可以代替 find，文件太多就歇菜了。 更强的别名：请参考 oh my zsh&gt;配置 一节。 插件支持：请参考 oh my zsh&gt;插件 一节。 oh my zsh安装「oh my zsh」可以自动安装也可以手动安装。 安装 自动安装：wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 手动安装：git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了： 配置zsh 的配置主要集中在用户当前目录的 .zshrc 里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字： > # Customize to your needs… 可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。 接下来进行别名的设置，我自己的部分配置如下： alias cls='clear' alias ll='ls -l' alias la='ls -a' alias vi='vim' alias javac="javac -J-Dfile.encoding=utf8" alias grep="grep --color=auto" alias -s html=mate # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开 alias -s rb=mate # 在命令行直接输入 ruby 文件，会在 TextMate 中打开 alias -s py=vi # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似 alias -s js=vi alias -s c=vi alias -s java=vi alias -s txt=vi alias -s gz='tar -xzvf' alias -s tgz='tar -xzvf' alias -s zip='unzip' alias -s bz2='tar -xjvf' zsh 不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如： alias -s html=mate意思就是你在命令行输入 hello.html，zsh 会为你自动打开 TextMat 并读取 hello.html； alias -s gz=&#39;tar -xzvf&#39;表示自动解压后缀为 gz 的压缩包。 总之，只有想不到，木有做不到。 设置完环境变量和别名之后，基本上就可以用了。 主题如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是： ZSH_THEME=”robbyrussell” oh my zsh 提供了数十种主题，相关文件在 ~/.oh-my-zsh/themes 目录下，你可以随意选择，也可以编辑主题满足自己的需求，我采用了默认主题robbyrussell，不过做了一点小小的改动： PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p%{$fg[cyan]%}%d %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%}% %{$reset_color%}>' #PROMPT='%{$fg_bold[red]%}➜ %{$fg_bold[green]%}%p %{$fg[cyan]%}%c %{$fg_bold[blue]%}$(git_prompt_info)%{$fg_bold[blue]%} % %{$reset_color%}' 对照原来的版本，我把 c 改为 d，c 表示当前目录，d 表示绝对路径，另外在末尾增加了一个「 &gt; 」。 ps：推荐主题： agnoster ys 插件oh my zsh 项目提供了完善的插件体系，相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用。想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。~/.oh-my-zsh//custom/plugins 添加用户自己的插件。插件在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下： plugins=(git textmate ruby autojump osx mvn gradle) 下面简单介绍几个： git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化。例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度。命令内容可以参考 ~/.oh-my-zsh/plugins/git/git.plugin.zsh。 textmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。 osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。 autojump：zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。 sudo：在指令的最前面按两下 ESC 加入 sudo 。不用再移动光标到头部了，sudo就会自动加入到最前面。 zsh-syntax-highlighting：可以在zsh中进行语法高亮。https://github.com/zsh-users/zsh-syntax-highlighting github上整理出来了很多的插件：awesome-zsh-plugins autojump首先安装autojump，如果你用 Mac，可以使用 brew 安装： brew install autojump 如果是 Linux，去下载 autojump 的最新版本，比如： wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz 解压缩后进入目录，执行 ./install.sh 最后把以下代码加入 .zshrc [[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh 至此，安装、配置、插件三位一体，终极 Shell 全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！ #tmux 官网： http://tmux.github.io/一个终端复用软件，可将终端方案化。 tmux安装使用brew就可以安装：brew install tmux tmux配置配置文件在：mvim ~/.tmux.conf 经常连接服务器用起来应该挺好用的。比如，在一个窗口中分隔成多个终端同时运行不同的命令。使用 SSH 的时候，在网络不稳定的情况下，可保存工作环境。在网络不好的环境下，可以尝试使用 Mosh 来代替 SSH 。 问题汇总vim无法打开文件删除以.zcompdump-开头的文件 rm -rf ~/.zcompdump-* exec zsh]]></content>
      <tags>
        <tag>mac</tag>
        <tag>zsh</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yarn和npm以及源的选择]]></title>
    <url>%2F2017%2F06%2F13%2Fyarn%E5%92%8Cnpm%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[Yarn是Facebook公司出品的用于管理nodejs包的一款软件，开发过nodejs的同学应该知道，我们一般都使用npm作为我们nodejs项目的模块管理器，但npm有一些历史遗留问题，首先，npm安装速度比较慢，而且当项目中模块数量越来越多时，管理这些模块及其依赖的版本是件令人头疼的事，其次npm在模块安装的过程中可以执行程序，安全性不高。yarn的存在正好解决了这些问题，模块安装速度简直快的令人发指，当某些模块通过yarn安装过后，再次安装甚至不需要连接网络；yarn也可以很好的控制模块依赖的版本（通过yarn.lock文件锁住），而且安全可靠。 yarn和npmyarn 介绍facebook发布的新一代包管理工具，旨在解决以往使用npm作为包管理会遇到的一些问题。从其官方介绍可以看到其重点强调的3个点：快、可靠、安全。 yarn拥有以下6个特性： 离线模式: 一次安装，永久使用，无需下载。 依赖确定性：安装依赖锁定，保证一致性。 更好的网络性能：下载包，优化网络请求，最大限度提高网络利用率。 多注册来源处理：不管依赖包被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装(npm/bower), 防止出现混乱不一致。 网络弹性处理: 安装依赖时，不会因为某个单次网络请求的失败导致整个安装挂掉。当请求失败时会进行自动重试。 扁平模式: 当关联依赖中包括对某个软件包的重复引用，在实际安装时将尽量避免重复的创建。 yarn.lock文件解决了npm存在一些历史遗留问题： 比如说你的项目模块依赖是图中描述的，@1.2.1代表这个模块的版本。在你安装A的时候需要安装依赖C和D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装模块的时候C和D是某一个版本，而当以后C、D更新的时候，再次安装模块就会安装C和D的最新版本，如果新的版本无法兼容你的项目，你的程序可能就会出BUG，甚至无法运行。这就是npm的弊端，而yarn为了解决这个问题推出了yarn.lock的机制，这是作者项目中的yarn.lock文件。 安装方法yarn可以通过npm直接安装：3npm install -g yarn 使用方法首先，yarn 的全局安装并不是加 -g 或者 –global 这样的参数，它使用 yarn global 命令。用 yarn global --help 可以看到子命令列表。 Usage: yarn global [add|bin|ls|remove|upgrade] [flags]这些子命令的用法和非 global 的同名命令用法差不多。 npm install === yarn / yarn install npm install xxx —save === yarn add xxx npm uninstall xxx —save === yarn remove xxx npm install xxx —save-dev === yarn add xxx —dev npm update === yarn upgrade npm install xxx -g === yarn global add xxx yarn list，根据当前项目的package.json查看模块的依赖及版本。 yarn info koa，查看koa模块的详细信息，类似于npm view koa。 yarn init，初始化项目package.json文件，等同于npm init。 yarn run，运行package.json中的script。 yarn还有很多有用的命令，很简单，可以通过yarn help获取帮助信息。 源的选择npm安装插件过程：从http://registry.npmjs.org下载对应的插件包（该网站服务器位于国外，所以经常下载缓慢或出现异常）。 cnpm和cyarn是解决nodejs源下载速度太慢的一个解决方案。 http://npm.taobao.org 是淘宝团队做的一个镜像网站，这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为10分钟一次以保证尽量与官方服务同步。源地址： https://registry.npm.taobao.org 安装cnpm和cyarn cnpm：npm install cnpm -g --registry=https://registry.npm.taobao.org或者使用 cnpm 源：npm install cnpm -g 注： “–registry=https://registry.npm.taobao.org&quot; 是临时使用源https://registry.npm.taobao.org 进行下载。 cyarn：npm install -g cyarn或者使用 cnpm 源：npm install -g cyarn --registry=https://registry.npm.taobao.org 其他修改源的方式 配置configyarn config set registry https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org 查看当前源npm config get registry]]></content>
      <tags>
        <tag>yarn</tag>
        <tag>npm</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-添加/删除用户和用户组]]></title>
    <url>%2F2017%2F06%2F09%2FLinux-%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本文总结了Linux添加或者删除用户和用户组时常用的一些命令和参数。转载自Linux添加/删除用户和用户组。 本文按照增、删、改、查的顺序进行介绍。 Linux添加/删除用户和用户组增（新建）建用户：adduser phpq //新建phpq用户 passwd phpq //给phpq用户设置密码 建工作组groupadd test //新建test工作组 新建用户同时增加工作组useradd -g test phpq //新建phpq用户并增加到test工作组 注：：-g 所属组 -d 家目录 -s 所用的SHELL 给已有的用户增加工作组usermod -G groupname username 或者： gpasswd -a user group 删临时关闭（停用账户）在/etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上*就可以了。想恢复该用户，去掉*即可。 或者使用如下命令关闭用户账号： passwd peter –l 重新释放： passwd peter –u 永久性删除用户账号userdel peter //删除用户 groupdel peter //删除用户组 usermod –G peter peter （强制删除该用户的主目录和主目录下的所有文件和子目录） 从组中删除用户编辑/etc/group 找到GROUP1那一行，删除 A 或者用命令 gpasswd -d A GROUP 查显示用户信息id user cat /etc/passwd Linux 用户和用户组管理概述Linux 是一个多用户、多任务的操作系统；我们应该了解单用户多任务和多用户多任务的概念； Linux 的单用户多任务单用户多任务；比如我们以beinan 登录系统，进入系统后，我要打开gedit 来写文档，但在写文档的过程中，我感觉少点音乐，所以又打开xmms 来点音乐；当然听点音乐还不行，MSN 还得打开，想知道几个弟兄现在正在做什么，这样一样，我在用beinan 用户登录时，执行了gedit 、xmms以及msn等，当然还有输入法fcitx ；这样说来就有点简单了，一个beinan用户，为了完成工作，执行了几个任务；当然beinan这个用户，其它的人还能以远程登录过来，也能做其它的工作。 Linux 的多用户多任务有时可能是很多用户同时用同一个系统，但并不所有的用户都一定都要做同一件事，所以这就有多用户多任务之说； 举个例子，比如LinuxSir.Org 服务器，上面有FTP 用户、系统管理员、web 用户、常规普通用户等，在同一时刻，可能有的弟兄正在访问论坛；有的可能在上传软件包管理子站，比如luma 或Yuking 兄在管理他们的主页系统和FTP ；在与此同时，可能还会有系统管理员在维护系统；浏览主页的用的是nobody 用户，大家都用同一个，而上传软件包用的是FTP用户；管理员的对系统的维护或查看，可能用的是普通帐号或超级权限root帐号；不同用户所具有的权限也不同，要完成不同的任务得需要不同的用户，也可以说不同的用户，可能完成的工作也不一样； 值得注意的是：多用户多任务并不是大家同时挤到一接在一台机器的的键盘和显示器前来操作机器，多用户可能通过远程登录来进行，比如对服务器的远程控制，只要有用户权限任何人都是可以上去操作或访问的； 用户的角色区分用户在系统中是分角色的，在Linux 系统中，由于角色不同，权限和所完成的任务也不同；值得注意的是用户的角色是通过UID和识别的，特别是UID；在系统管理中，系统管理员一定要坚守UID 唯一的特性； root 用户：系统唯一，是真实的，可以登录系统，可以操作系统任何文件和命令，拥有最高权限； 虚拟用户：这类用户也被称之为伪用户或假用户，与真实用户区分开来，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如bin、daemon、adm、ftp、mail等；这类用户都系统自身拥有的，而非后来添加的，当然我们也可以添加虚拟用户； 普通真实用户：这类用户能登录系统，但只能操作自己家目录的内容；权限有限；这类用户都是系统管理员自行添加的； 多用户操作系统的安全多用户系统从事实来说对系统管理更为方便。从安全角度来说，多用户管理的系统更为安全，比如beinan用户下的某个文件不想让其它用户看到，只是设置一下文件的权限，只有beinan一个用户可读可写可编辑就行了，这样一来只有beinan一个用户可以对其私有文件进行操作，Linux 在多用户下表现最佳，Linux能很好的保护每个用户的安全，但我们也得学会Linux 才是，再安全的系统，如果没有安全意识的管理员或管理技术，这样的系统也不是安全的。 从服务器角度来说，多用户的下的系统安全性也是最为重要的，我们常用的Windows 操作系统，它在系纺权限管理的能力只能说是一般般，根本没有没有办法和Linux或Unix 类系统相比； 用户和用户组概念用户（user）的概念通过前面对Linux 多用户的理解，我们明白Linux 是真正意义上的多用户操作系统，所以我们能在Linux系统中建若干用户（user）。比如我们的同事想用我的计算机，但我不想让他用我的用户名登录，因为我的用户名下有不想让别人看到的资料和信息（也就是隐私内容）这时我就可以给他建一个新的用户名，让他用我所开的用户名去折腾，这从计算机安全角度来说是符合操作规则的； 当然用户（user）的概念理解还不仅仅于此，在Linux系统中还有一些用户是用来完成特定任务的，比如nobody和ftp 等，我们访问LinuxSir.Org 的网页程序，就是nobody用户；我们匿名访问ftp 时，会用到用户ftp或nobody ；如果您想了解Linux系统的一些帐号，请查看 /etc/passwd ； 用户组（group）的概念用户组（group）就是具有相同特征的用户（user）的集合体；比如有时我们要让多个用户具有相同的权限，比如查看、修改某一文件或执行某个命令，这时我们需要用户组，我们把用户都定义到同一用户组，我们通过修改文件或目录的权限，让用户组具有一定的操作权限，这样用户组下的用户对该文件或目录都具有相同的权限，这是我们通过定义组和修改文件的权限来实现的； 举例：我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限，我们想让一些用户知道这个时间表的内容，而不让他们修改，所以我们可以把这些用户都划到一个组，然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的； 用户和用户组的对应关系是：一对一、多对一、一对多或多对多； 一对一：某个用户可以是某个组的唯一成员； 多对一：多个用户可以是某个唯一的组的成员，不归属其它用户组；比如beinan和linuxsir两个用户只归属于beinan用户组； 一对多：某个用户可以是多个用户组的成员；比如beinan可以是root组成员，也可以是linuxsir用户组成员，还可以是adm用户组成员； 多对多：多个用户对应多个用户组，并且几个用户可以是归属相同的组；其实多对多的关系是前面三条的扩展；理解了上面的三条，这条也能理解； 用户和用户组相关的配置文件、命令或目录与用户和用户组相关的配置文件与用户（user）相关的配置文件；/etc/passwd 注：用户（user）的配置文件； /etc/shadow 注：用户（user）影子口令文件； 与用户组（group）相关的配置文件；/etc/group 注：用户组（group）配置文件； /etc/gshadow 注：用户组（group）的影子文件； 管理用户和用户组的相关工具或命令管理用户（user）的工具或命令useradd 注：添加用户 adduser 注：添加用户 passwd 注：为用户设置密码 usermod 注：修改用户命令，可以通过usermod 来修改登录名、用户的家目录等等； pwcov 注：同步用户从/etc/passwd 到/etc/shadow pwck 注：pwck是校验用户配置文件/etc/passwd 和/etc/shadow 文件内容是否合法或完整； pwunconv 注：是pwcov 的立逆向操作，是从/etc/shadow和 /etc/passwd 创建/etc/passwd ， 然后会删除 /etc/shadow 文件； finger 注：查看用户信息工具 id 注：查看用户的UID、GID及所归属的用户组 chfn 注：更改用户信息工具 su 注：用户切换工具 sudo 注：sudo 是通过另一个用户来执行命令（execute a command as another user）， su 是用来切换用户，然后通过切换到的用户来完成相应的任务，但sudo 能后面直 接执行命令，比如sudo 不需要root 密码就可以执行root 赋与的执行只有root才 能执行相应的命令；但得通过visudo 来编辑/etc/sudoers来实现； visudo 注：visodo 是编辑 /etc/sudoers 的命令；也可以不用这个命令，直接用vi 来编辑 /etc/sudoers 的效果是一样的； sudoedit 注：和sudo 功能差不多； 管理用户组（group）的工具或命令groupadd 注：添加用户组； groupdel 注：删除用户组； groupmod 注：修改用户组信息 groups 注：显示用户所属的用户组 grpck grpconv 注：通过/etc/group和/etc/gshadow 的文件内容来同步或创建/etc/gshadow ，如果 /etc/gshadow 不存在则创建； grpunconv 注：通过/etc/group 和/etc/gshadow 文件内容来同步或创建/etc/group ，然后删除 gshadow文件； /etc/skel 目录/etc/skel目录一般是存放用户启动文件的目录，这个目录是由root权限控制，当我们添加用户时，这个目录下的文件自动复制到新添加的用户的家目录下；/etc/skel 目录下的文件都是隐藏文件，也就是类似.file格式的；我们可通过修改、添加、删除/etc/skel目录下的文件，来为用户提供一个统一、标准的、默认的用户环境； [root@localhost beinan]# ls -la /etc/skel/ 总用量 92 drwxr-xr-x 3 root root 4096 8月 11 23:32 . drwxr-xr-x 115 root root 12288 10月 14 13:44 .. -rw-r--r-- 1 root root 24 5月 11 00:15 .bash_logout -rw-r--r-- 1 root root 191 5月 11 00:15 .bash_profile -rw-r--r-- 1 root root 124 5月 11 00:15 .bashrc -rw-r--r-- 1 root root 5619 2005-03-08 .canna -rw-r--r-- 1 root root 438 5月 18 15:23 .emacs -rw-r--r-- 1 root root 120 5月 23 05:18 .gtkrc drwxr-xr-x 3 root root 4096 8月 11 23:16 .kde -rw-r--r-- 1 root root 658 2005-01-17 .zshrc /etc/skel 目录下的文件，一般是我们用useradd 和adduser 命令添加用户（user）时，系统自动复制到新添加用户（user）的家目录下；如果我们通过修改 /etc/passwd 来添加用户时，我们可以自己创建用户的家目录，然后把/etc/skel 下的文件复制到用户的家目录下，然后要用chown 来改变新用户家目录的属主； /etc/login.defs 配置文件/etc/login.defs 文件是当创建用户时的一些规划，比如创建用户时，是否需要家目录，UID和GID的范围；用户的期限等等，这个文件是可以通过root来定义的； 比如Fedora 的 /etc/logins.defs 文件内容； # *REQUIRED* # Directory where mailboxes reside, _or_ name of file, relative to the # home directory. If you _do_ define both, MAIL_DIR takes precedence. # QMAIL_DIR is for Qmail # #QMAIL_DIR Maildir MAIL_DIR /var/spool/mail 注：创建用户时，要在目录/var/spool/mail中创建一个用户mail文件； #MAIL_FILE .mail # Password aging controls: # # PASS_MAX_DAYS Maximum number of days a password may be used. # PASS_MIN_DAYS Minimum number of days allowed between password changes. # PASS_MIN_LEN Minimum acceptable password length. # PASS_WARN_AGE Number of days warning given before a password expires. # PASS_MAX_DAYS 99999 注：用户的密码不过期最多的天数； PASS_MIN_DAYS 0 注：密码修改之间最小的天数； PASS_MIN_LEN 5 注：密码最小长度； PASS_WARN_AGE 7 注： # # Min/max values for automatic uid selection in useradd # UID_MIN 500 注：最小UID为500 ，也就是说添加用户时，UID 是从500开始的； UID_MAX 60000 注：最大UID为60000； # # Min/max values for automatic gid selection in groupadd # GID_MIN 500 注：GID 是从500开始； GID_MAX 60000 # # If defined, this command is run when removing a user. # It should remove any at/cron/print jobs etc. owned by # the user to be removed (passed as the first argument). # #USERDEL_CMD /usr/sbin/userdel_local # # If useradd should create home directories for users by default # On RH systems, we do. This option is ORed with the -m flag on # useradd command line. # CREATE_HOME yes 注：是否创用户家目录，要求创建； /etc/default/useradd 文件通过useradd 添加用户时的规则文件； # useradd defaults file GROUP=100 HOME=/home 注：把用户的家目录建在/home中； INACTIVE=-1 注：是否启用帐号过期停权，-1表示不启用； EXPIRE= 注：帐号终止日期，不设置表示不启用； SHELL=/bin/bash 注：所用SHELL的类型； SKEL=/etc/skel 注：默认添加用户的目录默认文件存放位置；也就是说，当我们用adduser 添加用户时，用户家目录下的文件，都是从这个目录中复制过去的；]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-systemctl 系统服务管理]]></title>
    <url>%2F2017%2F06%2F08%2Flinux-systemctl%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[以前linux用的是service来进行服务管理，现在很多系统都使用systemctl进行管理，下面就来说说这两者之间的差异。 Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。Systemd的功能是用于集中管理和配置类UNIX系统。在Linux生态系统中，Systemd被部署到了大多数的标准Linux发行版中，只有为数不多的几个发行版尚未部署。Systemd通常是所有其它守护进程的父进程，但并非总是如此。 systemctl系统服务管理systemctl检查和分析系统中是否安装有systemd并确定当前安装的版本# systemctl --version systemd 215 +PAM +AUDIT +SELINUX +IMA +SYSVINIT +LIBCRYPTSETUP +GCRYPT +ACL +XZ -SECCOMP -APPARMOR 上例中很清楚地表明，我们安装了215版本的systemd。 systemd和systemctl的二进制文件和库文件的安装位置whereis systemd systemd: /usr/lib/systemd /etc/systemd /usr/share/systemd /usr/share/man/man1/systemd.1.gz whereis systemctl systemctl: /usr/bin/systemctl /usr/share/man/man1/systemctl.1.gz 检查systemd是否运行ps -eaf | grep [s]ystemd root 1 0 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 23 root 444 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-journald root 469 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-udevd root 555 1 0 16:27 ? 00:00:00 /usr/lib/systemd/systemd-logind dbus 556 1 0 16:27 ? 00:00:00 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation 注意：systemd是作为父进程（PID=1）运行的。在上面带（-e）参数的ps命令输出中，选择所有进程，（-a）选择除会话前导外的所有进程，并使用（-f）参数输出完整格式列表（即 -eaf）。 也请注意上例中后随的方括号和例子中剩余部分。方括号表达式是grep的字符类表达式的一部分。 分析systemd启动进程# systemd-analyze Startup finished in 487ms (kernel) + 2.776s (initrd) + 20.229s (userspace) = 23.493s 分析启动时各个进程花费的时间# systemd-analyze blame 8.565s mariadb.service 7.991s webmin.service 6.095s postfix.service 4.311s httpd.service 3.926s firewalld.service 3.780s kdump.service 3.238s tuned.service 1.712s network.service 1.394s lvm2-monitor.service 1.126s systemd-logind.service .... 分析启动时的关键链# systemd-analyze critical-chain The time after the unit is active or started is printed after the "@" character. The time the unit takes to start is printed after the "+" character. multi-user.target @20.222s └─mariadb.service @11.657s +8.565s └─network.target @11.168s └─network.service @9.456s +1.712s └─NetworkManager.service @8.858s +596ms └─firewalld.service @4.931s +3.926s └─basic.target @4.916s └─sockets.target @4.916s └─dbus.socket @4.916s └─sysinit.target @4.905s └─systemd-update-utmp.service @4.864s +39ms └─auditd.service @4.563s +301ms └─systemd-tmpfiles-setup.service @4.485s +69ms └─rhel-import-state.service @4.342s +142ms └─local-fs.target @4.324s └─boot.mount @4.286s +31ms └─systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d19608096 └─dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4 重要：Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。 列出所有可用单元# systemctl list-unit-files UNIT FILE STATE proc-sys-fs-binfmt_misc.automount static dev-hugepages.mount static dev-mqueue.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount disabled brandbot.path disabled ..... 列出所有运行中单元# systemctl list-units UNIT LOAD ACTIVE SUB DESCRIPTION proc-sys-fs-binfmt_misc.automount loaded active waiting Arbitrary Executable File Formats File Syste sys-devices-pc...0-1:0:0:0-block-sr0.device loaded active plugged VBOX_CD-ROM sys-devices-pc...:00:03.0-net-enp0s3.device loaded active plugged PRO/1000 MT Desktop Adapter sys-devices-pc...00:05.0-sound-card0.device loaded active plugged 82801AA AC'97 Audio Controller sys-devices-pc...:0:0-block-sda-sda1.device loaded active plugged VBOX_HARDDISK sys-devices-pc...:0:0-block-sda-sda2.device loaded active plugged LVM PV Qzyo3l-qYaL-uRUa-Cjuk-pljo-qKtX-VgBQ8 sys-devices-pc...0-2:0:0:0-block-sda.device loaded active plugged VBOX_HARDDISK sys-devices-pl...erial8250-tty-ttyS0.device loaded active plugged /sys/devices/platform/serial8250/tty/ttyS0 sys-devices-pl...erial8250-tty-ttyS1.device loaded active plugged /sys/devices/platform/serial8250/tty/ttyS1 sys-devices-pl...erial8250-tty-ttyS2.device loaded active plugged /sys/devices/platform/serial8250/tty/ttyS2 sys-devices-pl...erial8250-tty-ttyS3.device loaded active plugged /sys/devices/platform/serial8250/tty/ttyS3 sys-devices-virtual-block-dm\x2d0.device loaded active plugged /sys/devices/virtual/block/dm-0 sys-devices-virtual-block-dm\x2d1.device loaded active plugged /sys/devices/virtual/block/dm-1 sys-module-configfs.device loaded active plugged /sys/module/configfs ... 列出所有失败单元# systemctl --failed UNIT LOAD ACTIVE SUB DESCRIPTION kdump.service loaded failed failed Crash recovery kernel arming LOAD = Reflects whether the unit definition was properly loaded. ACTIVE = The high-level unit activation state, i.e. generalization of SUB. SUB = The low-level unit activation state, values depend on unit type. 1 loaded units listed. Pass --all to see loaded but inactive units, too. To show all installed unit files use 'systemctl list-unit-files'. 使用Systemctl控制并管理服务检查某个单元或服务的状态# systemctl status firewalld.service firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled) Active: active (running) since Tue 2015-04-28 16:27:55 IST; 34min ago Main PID: 549 (firewalld) CGroup: /system.slice/firewalld.service └─549 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid Apr 28 16:27:51 tecmint systemd[1]: Starting firewalld - dynamic firewall daemon... Apr 28 16:27:55 tecmint systemd[1]: Started firewalld - dynamic firewall daemon. 检查某个单元（如 cron.service）是否启用（运行）# systemctl is-active crond.service active 列出所有服务（包括启用的和禁用的）# systemctl list-unit-files --type=service UNIT FILE STATE arp-ethers.service disabled auditd.service enabled autovt@.service disabled blk-availability.service disabled brandbot.service static collectd.service disabled console-getty.service disabled console-shell.service disabled cpupower.service disabled crond.service enabled dbus-org.fedoraproject.FirewallD1.service enabled .... Linux中启动、重启、停止服务# systemctl start httpd.service # systemctl restart httpd.service # systemctl stop httpd.service # systemctl reload httpd.service # systemctl status httpd.service 注意：当我们使用systemctl的start，restart，stop和reload命令时，我们不会从终端获取到任何输出内容，只有status命令可以打印输出。 查询和设置开机启动服务# systemctl is-enable httpd.service enable # systemctl enable httpd.service # systemctl disable httpd.service 屏蔽（不能启动）或显示服务（如 httpd.service）# systemctl mask httpd.service ln -s '/dev/null' '/etc/systemd/system/httpd.service' # systemctl unmask httpd.service rm '/etc/systemd/system/httpd.service' 使用systemctl命令杀死服务# systemctl kill httpd # systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: failed (Result: exit-code) since Tue 2015-04-28 18:01:42 IST; 28min ago Main PID: 2881 (code=exited, status=0/SUCCESS) Status: "Total requests: 0; Current requests/sec: 0; Current traffic: 0 B/sec" Apr 28 17:37:29 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:29 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:39 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:39 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:49 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:49 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:59 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 17:37:59 tecmint systemd[1]: httpd.service: Got notification message from PID 2881, but recepti...bled. Apr 28 18:01:42 tecmint systemd[1]: httpd.service: control process exited, code=exited status=226 Apr 28 18:01:42 tecmint systemd[1]: Unit httpd.service entered failed state. Hint: Some lines were ellipsized, use -l to show in full. 使用Systemctl控制并管理挂载点列出所有系统挂载点# systemctl list-unit-files --type=mount UNIT FILE STATE dev-hugepages.mount static dev-mqueue.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount disabled 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态# systemctl start tmp.mount # systemctl stop tmp.mount # systemctl restart tmp.mount # systemctl reload tmp.mount # systemctl status tmp.mount tmp.mount - Temporary Directory Loaded: loaded (/usr/lib/systemd/system/tmp.mount; disabled) Active: active (mounted) since Tue 2015-04-28 17:46:06 IST; 2min 48s ago Where: /tmp What: tmpfs Docs: man:hier(7) http://www.freedesktop.org/wiki/Software/systemd/APIFileSystems Process: 3908 ExecMount=/bin/mount tmpfs /tmp -t tmpfs -o mode=1777,strictatime (code=exited, status=0/SUCCESS) Apr 28 17:46:06 tecmint systemd[1]: Mounting Temporary Directory... Apr 28 17:46:06 tecmint systemd[1]: tmp.mount: Directory /tmp to mount over is not empty, mounting anyway. Apr 28 17:46:06 tecmint systemd[1]: Mounted Temporary Directory. 查询，激活或禁用在启动时自动挂载# systemctl is-enable tmp.mount # systemctl enable tmp.mount # systemctl disable tmp.mount 在Linux中屏蔽（让它不能启用）或可见挂载点# systemctl mask tmp.mount ln -s '/dev/null' '/etc/systemd/system/tmp.mount' # systemctl unmask tmp.mount rm '/etc/systemd/system/tmp.mount' 使用Systemctl控制并管理套接口列出所有可用系统套接口# systemctl list-unit-files --type=socket UNIT FILE STATE dbus.socket static dm-event.socket enabled lvm2-lvmetad.socket enabled rsyncd.socket disabled sshd.socket disabled syslog.socket static systemd-initctl.socket static systemd-journald.socket static systemd-shutdownd.socket static systemd-udevd-control.socket static systemd-udevd-kernel.socket static 11 unit files listed. 在Linux中启动、重启、停止、重载套接口并检查其状态# systemctl start cups.socket # systemctl restart cups.socket # systemctl stop cups.socket # systemctl reload cups.socket # systemctl status cups.socket cups.socket - CUPS Printing Service Sockets Loaded: loaded (/usr/lib/systemd/system/cups.socket; enabled) Active: active (listening) since Tue 2015-04-28 18:10:59 IST; 8s ago Listen: /var/run/cups/cups.sock (Stream) Apr 28 18:10:59 tecmint systemd[1]: Starting CUPS Printing Service Sockets. Apr 28 18:10:59 tecmint systemd[1]: Listening on CUPS Printing Service Sockets. 查询，激活或禁用套接口在启动时自动启动# systemctl is-enable cups.socket # systemctl enable cups.socket # systemctl disable cups.socket 屏蔽（使它不能启动）或显示套接口# systemctl mask cups.socket ln -s '/dev/null' '/etc/systemd/system/cups.socket' # systemctl unmask cups.socket rm '/etc/systemd/system/cups.socket' 服务的CPU利用率（分配额）获取当前某个服务的CPU分配额（如httpd）# systemctl show -p CPUShares httpd.service CPUShares=1024 注意：各个服务的默认CPU分配份额=1024，你可以增加/减少某个进程的CPU分配份额。 将某个服务的CPU分配份额限制为2000 CPUShares/# systemctl set-property httpd.service CPUShares=2000 # systemctl show -p CPUShares httpd.service CPUShares=2000 注意：当你为某个服务设置CPUShares，会自动创建一个以服务名命名的目录（如 httpd.service），里面包含了一个名为90-CPUShares.conf的文件，该文件含有CPUShare限制信息，你可以通过以下方式查看该文件： # vi /etc/systemd/system/httpd.service.d/90-CPUShares.conf [Service] CPUShares=2000 检查某个服务的所有配置细节# systemctl show httpd Id=httpd.service Names=httpd.service Requires=basic.target Wants=system.slice WantedBy=multi-user.target Conflicts=shutdown.target Before=shutdown.target multi-user.target After=network.target remote-fs.target nss-lookup.target systemd-journald.socket basic.target system.slice Description=The Apache HTTP Server LoadState=loaded ActiveState=active SubState=running FragmentPath=/usr/lib/systemd/system/httpd.service .... 分析某个服务（httpd）的关键链# systemd-analyze critical-chain httpd.service The time after the unit is active or started is printed after the "@" character. The time the unit takes to start is printed after the "+" character. httpd.service +142ms └─network.target @11.168s └─network.service @9.456s +1.712s └─NetworkManager.service @8.858s +596ms └─firewalld.service @4.931s +3.926s └─basic.target @4.916s └─sockets.target @4.916s └─dbus.socket @4.916s └─sysinit.target @4.905s └─systemd-update-utmp.service @4.864s +39ms └─auditd.service @4.563s +301ms └─systemd-tmpfiles-setup.service @4.485s +69ms └─rhel-import-state.service @4.342s +142ms └─local-fs.target @4.324s └─boot.mount @4.286s +31ms └─systemd-fsck@dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.service @4.092s +149ms └─dev-disk-by\x2duuid-79f594ad\x2da332\x2d4730\x2dbb5f\x2d85d196080964.device @4.092s 获取某个服务（httpd）的依赖性列表# systemctl list-dependencies httpd.service httpd.service ├─system.slice └─basic.target ├─firewalld.service ├─microcode.service ├─rhel-autorelabel-mark.service ├─rhel-autorelabel.service ├─rhel-configure.service ├─rhel-dmesg.service ├─rhel-loadmodules.service ├─paths.target ├─slices.target │ ├─-.slice │ └─system.slice ├─sockets.target │ ├─dbus.socket .... 按等级列出控制组# systemd-cgls ├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 23 ├─user.slice │ └─user-0.slice │ └─session-1.scope │ ├─2498 sshd: root@pts/0 │ ├─2500 -bash │ ├─4521 systemd-cgls │ └─4522 systemd-cgls └─system.slice ├─httpd.service │ ├─4440 /usr/sbin/httpd -DFOREGROUND │ ├─4442 /usr/sbin/httpd -DFOREGROUND │ ├─4443 /usr/sbin/httpd -DFOREGROUND │ ├─4444 /usr/sbin/httpd -DFOREGROUND │ ├─4445 /usr/sbin/httpd -DFOREGROUND │ └─4446 /usr/sbin/httpd -DFOREGROUND ├─polkit.service │ └─721 /usr/lib/polkit-1/polkitd --no-debug .... 按CPU、内存、输入和输出列出控制组# systemd-cgtop Path Tasks %CPU Memory Input/s Output/s / 83 1.0 437.8M - - /system.slice - 0.1 - - - /system.slice/mariadb.service 2 0.1 - - - /system.slice/tuned.service 1 0.0 - - - /system.slice/httpd.service 6 0.0 - - - /system.slice/NetworkManager.service 1 - - - - /system.slice/atop.service 1 - - - - /system.slice/atopacct.service 1 - - - - /system.slice/auditd.service 1 - - - - /system.slice/crond.service 1 - - - - /system.slice/dbus.service 1 - - - - /system.slice/firewalld.service 1 - - - - /system.slice/lvm2-lvmetad.service 1 - - - - /system.slice/polkit.service 1 - - - - /system.slice/postfix.service 3 - - - - /system.slice/rsyslog.service 1 - - - - /system.slice/system-getty.slice/getty@tty1.service 1 - - - - /system.slice/systemd-journald.service 1 - - - - /system.slice/systemd-logind.service 1 - - - - /system.slice/systemd-udevd.service 1 - - - - /system.slice/webmin.service 1 - - - - /user.slice/user-0.slice/session-1.scope 3 - - - - 控制系统运行等级启动系统救援模式# systemctl rescue Broadcast message from root@tecmint on pts/0 (Wed 2015-04-29 11:31:18 IST): The system is going down to rescue mode NOW! 进入紧急模式# systemctl emergency Welcome to emergency mode! After logging in, type "journalctl -xb" to view system logs, "systemctl reboot" to reboot, "systemctl default" to try again to boot into default mode. 列出当前使用的运行等级# systemctl get-default multi-user.target 启动运行等级5，即图形模式# systemctl isolate runlevel5.target 或 # systemctl isolate graphical.target 启动运行等级3，即多用户模式（命令行）# systemctl isolate runlevel3.target 或 # systemctl isolate multiuser.target 设置多用户模式或图形模式为默认运行等级# systemctl set-default runlevel3.target # systemctl set-default runlevel5.target 重启、停止、挂起、休眠系统或使系统进入混合睡眠# systemctl reboot # systemctl halt # systemctl suspend # systemctl hibernate # systemctl hybrid-sleep 运行等级为何物，说明如下。 Runlevel 0 : 关闭系统 Runlevel 1 : 救援？维护模式 Runlevel 3 : 多用户，无图形系统 Runlevel 4 : 多用户，无图形系统 Runlevel 5 : 多用户，图形化系统 Runlevel 6 : 关闭并重启机器]]></content>
      <tags>
        <tag>linux</tag>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-页面跳转]]></title>
    <url>%2F2017%2F06%2F08%2Fjs-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[在使用html的frame框架搭建网页时，会出现需要框架页顶层窗口跳转，这个时候我们使用的是window.location.href 介绍self.location.href="/url" //当前页面打开URL页面 location.href="/url" //当前页面打开URL页面 windows.location.href="/url" //当前页面打开URL页面，前面三个用法相同。 this.location.href="/url" //当前页面打开URL页面 parent.location.href="/url" //在父页面打开新页面 top.location.href="/url" //在顶层页面打开新页面 frame如果页面中自定义了frame，那么可将parent，self， top 换为自定义frame的名称,效果是在frame窗口打开url地址。 此外，window.location.href=window.location.href;和window.location.Reload()都是刷新当前页面。区别在于是否有提交数据。 当有提交数据时： window.location.Reload() 会提示是否提交 window.location.href=window.location.href; 则是向指定的url提交数据]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jqurey-条件选择器]]></title>
    <url>%2F2017%2F06%2F08%2Fjqurey-%E6%9D%A1%E4%BB%B6%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[jquery的条件选择器是用来对html标签进行选择，从而获取属性值，改变css样式，标签内的文本等等。。。大多时候用jqurey()...{}来进行条件筛选，为了方便使用也可以用简写$()...{}。 jqurey选择器 选择器 实例 选取 * $(“*”) 所有元素 #id $(“#lastname”) id=”lastname” 的元素 .class $(“.intro”) 所有 class=”intro” 的元素 element $(“p”) 所有 &lt;p&gt; 元素 .class.class $(“.intro.demo”) 所有 class=”intro” 且 class=”demo” 的元素 &nbsp; :first $(“p:first”) 第一个 &lt;p&gt; 元素 :last $(“p:last”) 最后一个 &lt;p&gt; 元素 :even $(“tr:even”) 所有偶数 &lt;tr&gt; 元素 :odd $(“tr:odd”) 所有奇数 &lt;tr&gt; 元素 &nbsp; :eq(index) $(“ul li:eq(3)”) 列表中的第四个元素（index 从 0 开始） :gt(no) $(“ul li:gt(3)”) 列出 index 大于 3 的元素 :lt(no) $(“ul li:lt(3)”) 列出 index 小于 3 的元素 :not(selector) $(“input:not(:empty)”) 所有不为空的 input 元素 &nbsp; :header $(“:header”) 所有标题元素 &lt;h1&gt; - &lt;h6&gt; :animated $(“:animated”) 所有动画元素 &nbsp; :contains(text) $(“:contains(‘W3School’)”) 包含指定字符串的所有元素 :empty $(“:empty”) 无子（元素）节点的所有元素 :hidden $(“p:hidden”) 所有隐藏的 &lt;p&gt; 元素 :visible $(“table:visible”) 所有可见的表格 &nbsp; s1,s2,s3 $(“th,td,.intro”) 所有带有匹配选择的元素 &nbsp; [attribute] $(“[href]”) 所有带有 href 属性的元素 [attribute=value] $(“[href=’#’]”) 所有 href 属性的值等于 “#” 的元素 [attribute!=value] $(“[href!=’#’]”) 所有 href 属性的值不等于 “#” 的元素 [attribute$=value] $(“[href$=’.jpg’]”) 所有 href 属性的值包含以 “.jpg” 结尾的元素 &nbsp; :input $(“:input”) 所有 &lt;input&gt; 元素 :text $(“:text”) 所有 type=”text” 的 &lt;input&gt; 元素 :password $(“:password”) 所有 type=”password” 的 &lt;input&gt; 元素 :radio $(“:radio”) 所有 type=”radio” 的 &lt;input&gt; 元素 :checkbox $(“:checkbox”) 所有 type=”checkbox” 的 &lt;input&gt; 元素 :submit $(“:submit”) 所有 type=”submit” 的 &lt;input&gt; 元素 :reset $(“:reset”) 所有 type=”reset” 的 &lt;input&gt; 元素 :button $(“:button”) 所有 type=”button” 的 &lt;input&gt; 元素 :image $(“:image”) 所有 type=”image” 的 &lt;input&gt; 元素 :file $(“:file”) 所有 type=”file” 的 &lt;input&gt; 元素 &nbsp; :enabled $(“:enabled”) 所有激活的 input 元素 :disabled $(“:disabled”) 所有禁用的 input 元素 :selected $(“:selected”) 所有被选取的 input 元素 :checked $(“:checked”) 所有被选中的 input 元素 有的还可以写成成员调用的样式，比如$(“ul li:eq(3)”) 可以写成 $(“ul li”).eq(3)。 过滤选择器的混合使用时要记住后面的过滤条件是以前面的过滤选择器过滤后的重新序号为基础，即过滤的逐级性，比如$(&quot;#t1 tr:gt(0):lt(3)&quot;).css(&quot;fontSize&quot;, &quot;28&quot;); //lt(3)是从gt(0)出的新序列中的序号，不要写成lt(4) 条件选择器多条件选择器$(&quot;p,div,span menuitem&quot;)，同时选择p元素，div元素，和span元素下的所以后代元素menuitem 注意：选择器表达式中的空格不能多不能少，易错！ 同条件选择器$(&quot;.button.color.ttt&quot;)选中一个具有多个class的元素，即class=”button color ttt”。 相对选择器&lt;table id="table1"> &lt;tr>&lt;td>dsds&lt;/td>&lt;td>dsfdef&lt;/td>&lt;/tr> &lt;tr>&lt;td>dsds&lt;/td>&lt;td>dsfdef&lt;/td>&lt;/tr> &lt;tr>&lt;td>dsds&lt;/td>&lt;td>dsfdef&lt;/td>&lt;/tr> &lt;tr>&lt;td>dsds&lt;/td>&lt;td>dsfdef&lt;/td>&lt;/tr> &lt;tr>&lt;td>dsds&lt;/td>&lt;td>dsfdef&lt;/td>&lt;/tr> &lt;/table> 那么可以用如下的js代码操作td的背景色 $("#table1 tr").click(function () { $("td", $(this)).css("background", "red"); //不使用$(this)，直接用this也是可以的 //如果直接使用"#table1 tr"全部的"#table1 tr"都将改变 }); 这句代码用的就是相对选择器，选择的td元素是当前的tr元素下的所有td元素，没有涉及到其他行的td元素，$(this)指的是被选中的&quot;#table1 tr&quot;，要改变的元素是被点击的&quot;#table1 tr&quot;中的td。 层次选择器 $(&quot;#div li&quot;)获取div下的所有后代（descendants）li元素（后代，子，子的子….） $(&quot;#div &gt; li&quot;)获取div下的直接子元素li（children）//注意空格 $(&quot;.menuitem + div&quot;)获取class名为menuitem之后的第一个div元素，不常用。 $(&quot;.menuitem ~ div&quot;)获取class名为menuitem之后的所有的div元素，不常用。]]></content>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-换行]]></title>
    <url>%2F2017%2F06%2F01%2Fcss-%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在CSS中，控制换行的有3个属性，分别是：white-space、word-break、word-wrap ，下面我们依次介绍3个属性。 其中white-space 的&lt;pre&gt;是用的最多的，保证了自定义单词的完整性，空白会被保留，然后进行强制转行。 white-space 值 描述 normal 默认。空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 pre 保留单词结构，如果单词太长会直接跳转下一行进行显示，上一行用空白保留。 word-break 值 描述 normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 break-all 会打破单词结构强制换行。 word-wrap 值 描述 normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。 break-word 会打破长单词结构强制换行。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-crontab 添加计划任务]]></title>
    <url>%2F2017%2F05%2F31%2Flinux-crontab%2F</url>
    <content type="text"><![CDATA[很多linux程序需要周期性的执行，比如备份，重启服务等等。我们可以使用crontab命令来进行linux系统的计划任务。 crontab 介绍在/etc 文件夹下面有 4个文件夹1个文件 分别是：cron.d/、cron.daily/、cron.hourly/、cron.monthly/、cron.weekly/、crontab 。 cron.daily是每天执行一次的job.cron.weekly是每个星期执行一次的job.cron.monthly是每月执行一次的job.cron.hourly是每个小时执行一次的job. cron.d是系统自动定期需要做的任务，但是又不是按小时，按天，按星期，按月来执行的，那么就放在这个目录下面。如果是按小时，按天，按星期，按月的来执行的话，则可以放到前面相应的目录下面去。linux的cron服务是每隔一分钟去读取一次/var/spool/cron，/etc/crontab,/etc/cron.d下面所有的内容。 crontab 主配置文件cron 的主配置文件是 /etc/crontab，它包括下面几行： SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # m h dom mon dow user command 17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly ) 前两行是用来配置 cron 任务运行环境的变量。SHELL 变量的值告诉系统要使用哪个 shell 环境（在这个例子里是 bash shell）；PATH 变量定义用来执行命令的路径。cron 任务的输出被邮寄给 MAILTO 变量定义的用户名。如果 MAILTO 变量被定义为空白字符串（MAILTO = “ “），电子邮件就不会被寄出。HOME 变量可以用来设置在执行命令或脚本时使用的主目录。 crontab 使用crontab -h 可以查看crontab的参数说明。 crontab -e 编辑用户的计划任务。 crontab -l 列出用户的计划任务。 crontab 命令格式基本格式# m h day mon dow user command * * * * * command 分 时 日 月 周 命令 | minute | hour | day | month | dayofweek | command | minute — 分钟，从 0 到 59 之间的任何整数 hour — 小时，从 0 到 23 之间的任何整数 day — 日期，从 1 到 31 之间的任何整数（如果指定了月份，必须是该月份的有效日期） month — 月份，从 1 到 12 之间的任何整数（或使用月份的英文简写如 jan、feb 等等） dayofweek — 星期，从 0 到 7 之间的任何整数，这里的 0 或 7 代表星期日（或使用星期的英文简写如 sun、mon 等等） command — 要执行的命令（命令可以是ls /proc &gt;&gt; /tmp/proc 之类的命令，也可以是执行你自行编写的脚本的命令。） 星号（*）代表取值范围内的数字。譬如，月份值中的星号意味着在满足其它制约条件后每月都执行。整数间的短线（-）代表从某个数字到某个数字。譬如，1-4 意味着整数 1、2、3、4。用逗号（,）代表分开几个离散的数字。譬如，3, 4, 6, 8 标明这四个指定的整数。正斜线（/）代表”每”，可以用来指定间隔频率。在范围后加上 /&lt;integer&gt; 意味着在范围内可以跳过 integer。譬如，0-59/2 可以用来在分钟字段定义每两分钟。间隔频率值还可以和星号一起使用。例如，*/3 的值可以用在月份字段中表示每三个月运行一次任务。 例子5 * * * * ls #指定每小时的第5分钟执行一次ls命令 30 5 * * * ls #指定每天的 5:30 执行ls命令 30 7 8 * * ls #指定每月8号的7：30分执行ls命令 30 5 8 6 * ls #指定每年的6月8日5：30执行ls命令 30 6 * * 0 ls #指定每星期日的6:30执行ls命令 #[注：0表示星期天，1表示星期1，以此类推， #也可以用英文来表示，sun表示星期天，mon表示星期一等。] 30 3 10,20 * * ls #每月10号及20号的3：30执行ls命令 #[注：“，”用来连接多个不连续的时段] 25 8-11 * * * ls #每天8-11点的第25分钟执行ls命令 #[注：“-”用来连接连续的时段] */15 * * * * ls #每15分钟执行一次ls命令 #[即每个小时的第0 15 30 45 60分钟执行ls命令] 30 6 */10 * * ls #每个月中，每隔10天6:30执行一次ls命令 #[即每月的1、11、21、31日是的6：30执行一次ls 命令。] 50 7 * * * root run-parts /etc/cron.daily #每天7：50以root 身份执行/etc/cron.daily目录中的所有可执行文件 #[注：run-parts参数表示，执行后面目录中的所有可执行文件。] 控制对 cron 的使用/etc/cron.allow 和/etc/cron.deny 文件被用来限制对 cron 的使用。这两个使用控制文件的格式都是每行一个用户。两个文件都不允许空格。如果使用控制文件被修改了，cron 守护进程（crond）不必被重启。使用控制文件在每次用户添加或删除一项 cron 任务时都会被读取。 无论使用控制文件中的规定如何，根用户都总是可以使用 cron。 如果 cron.allow 文件存在，只有其中列出的用户才被允许使用 cron，并且cron.deny 文件会被忽略。 如果 cron.allow 文件不存在，所有在cron.deny 中列出的用户都被禁止使用 cron。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-lsof]]></title>
    <url>%2F2017%2F05%2F31%2FLinux-lsof%2F</url>
    <content type="text"><![CDATA[lsof（list open files）是一个列出当前系统打开文件的工具。在Linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以，lsof的功能很强大。一般root用户才能执行lsof命令，普通用户可以看见/usr/sbin/lsof命令，但是普通用户执行会显示“permission denied”。因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。 lsof输出各列信息的意义COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME init 1 root cwd DIR 8,1 4096 2 / init 1 root rtd DIR 8,1 4096 2 / init 1 root txt REG 8,1 150584 654127 /sbin/init udevd 415 root 0u CHR 1,3 0t0 6254 /dev/null udevd 415 root 1u CHR 1,3 0t0 6254 /dev/null udevd 415 root 2u CHR 1,3 0t0 6254 /dev/null udevd 690 root mem REG 8,1 51736 302589 /lib/x86_64-linux-gnu/libnss_files-2.13.so syslogd 1246 syslog 2w REG 8,1 10187 245418 /var/log/auth.log syslogd 1246 syslog 3w REG 8,1 10118 245342 /var/log/syslog dd 1271 root 0r REG 0,3 0 4026532038 /proc/kmsg dd 1271 root 1w FIFO 0,15 0t0 409 /run/klogd/kmsg dd 1271 root 2u CHR 1,3 0t0 6254 /dev/null COMMAND：进程的名称 PID：进程标识符 USER：进程所有者 FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等 DEVICE：指定磁盘的名称 SIZE：文件的大小 NODE：索引节点（文件在磁盘上的标识） NAME：打开文件的确切名称 参数lsof abc.txt 显示开启文件abc.txt的进程 lsof -i :22 知道22端口被哪个进程占用 lsof -c abc 显示abc进程现在打开的文件 lsof -g gid 显示归属gid的进程情况 lsof -n 不将IP转换为hostname，缺省是不加上-n参数 lsof -p 12 看进程号为12的进程打开了哪些文件 lsof -u username 查看用户打开哪些文件 lsof -i @192.168.1.111 查看远程已打开的网络连接（连接到192.168.1.111） 总结我感觉这个lsof有点像ps+netstat的结合，很多时候我我们知道端口号要去查询PID的时候就要通过netstat -apn或者 netstat -tapn 进行查找后,在用进程名去进行 ps -aux |grep 进程名 进行查找如果通过lsof -i :端口号 可以一次进行查找。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL 数据建模技术]]></title>
    <url>%2F2017%2F05%2F29%2FNoSQL%20%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[今天在果壳网看见一篇关于NoSQL 数据建模技术的介绍很有意思转载了过来。 数据库事务必须具备ACID特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。 原子性：指整个数据库事务是不可分割的工作单位。只有使据库中所有的操作执行成功，才算整个事务成功；事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。 一致性：指数据库事务不能破坏关系数据的完成性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。 隔离性：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。 持久性：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 NoSQL放弃了数据的一致性，所以数据库的document（table）的关系是很弱的。关系型数据库中，我的理解是，主键和外键保证了数据的一致性。若是用户发表过文章，在用户表中是无法删除用户的，必须先把用户发表的文章删除（把用户表和其他表的关系切断）才可以删除。这样做保证了数据的一致性。NoSQL为了保证速度，放弃了数据的一致性。由于现在很多的业务并不需要严格保证数据的一致性，这一点上是可取的。 NoSQL 数据建模技术全文译自墙外文章“NoSQL Data Modeling Techniques”，译得不好，还请见谅。这篇文章看完之后，你可能会对NoSQL的数据结构会有些感觉。我的感觉是，关系型数据库想把一致性，完整性，索引，CRUD都干好，NoSQL只干某一种事，但是牺牲了很多别的东西。总体来说，我觉得NoSQL更适合做Cache。下面是正文—— NoSQL 数据库经常被用作很多非功能性的地方，如，扩展性，性能和一致性的地方。这些NoSQL的特性在理论和实践中都正在被大众广泛地研究着，研究的热点正是那些和性能分布式相关的非功能性的东西，我们都知道 CAP 理论被很好地应用于了 NoSQL 系统中（陈皓注：CAP即，一致性(Consistency)， 可用性(Availability)， 分区容忍性(Partition tolerance)，在分布式系统中，这三个要素最多只能同时实现两个，而NoSQL一般放弃的是一致性）。但在另一方面，NoSQL的数据建模技术却因为缺乏像关系型数据库那样的基础理论没有被世人很好地研究。这篇文章从数据建模方面对NoSQL家族进行了比较，并讨论几个常见的数据建模技术。 要开始讨论数据建模技术，我们不得不或多或少地先系统地看一下NoSQL数据模型的成长的趋势，以此我们可以了解一些他们内在的联系。下图是NoSQL家族的进化图，我们可以看到这样的进化：Key-Value时代，BigTable时代，Document时代，全文搜索时代，和Graph数据库时代：（陈皓注：注意图中SQL说的那句话，NoSQL再这样发展下去就是SQL了，哈哈。） ![](NoSQL 数据建模技术/2017-05-29-18-33-30.png) *NoSQL Data Models* 首先，我们需要注意的是SQL和关系型数据模型已存在了很长的时间，这种面向用户的自然性意味着： 最终用户一般更感兴趣于数据的聚合显示，而不是分离的数据，这主要通过SQL来完成。 我们无法通过人手工控制数据的并发性，完整性，一致性，或是数据类型校验这些东西的。这就是为什么SQL需要在事务，二维表结构（schema）和外表联合上做很多事。 另一方面，SQL可以让软件应用程序在很多情况下不需要关心数据库的数据聚合，和数据完整性和有效性进行控制。而如果我们去除了数据一致性，完整性这些东西，会对性能和分布存储有着重的帮助。正因为如此，我们才有数据模型的进化： Key-Value 键值对存储是非常简单而强大的。下面的很多技术基本上都是基于这个技术开始发展的。但是，Key-Value有一个非常致命的问题，那就是如果我们需要查找一段范围内的key。（陈皓注：学过hash-table数据结构的人都应该知道，hash-table是非序列容器，其并不像数组，链接，队列这些有序容器，我们可以控制数据存储的顺序）。于是，有序键值 （Ordered Key-Value） 数据模型被设计出来解决这一限制，来从根本上提高数据集的问题。 Ordered Key-Value 有序键值模型也非常强大，但是，其也没有对Value提供某种数据模型。通常来说，Value的模型可以由应用负责解析和存取。这种很不方便，于是出现了 BigTable类型的数据库，这个数据模型其实就是map里有map，map里再套map，一层一层套下去，也就是层层嵌套的key-value（value里又是一个key-value），这种数据库的Value主要通过“列族”（column families），列，和时间戳来控制版本。（陈皓注：关于时间戳来对数据的版本控制主要是解决数据存储并发问题，也就是所谓的乐观锁，详见《多版本并发控制(MVCC)在分布式系统中的应用》） Document databases 文档数据库 改进了 BigTable 模型，并提供了两个有意义的改善。第一个是允许Value中有主观的模式（scheme），而不是map套map。第二个是索引。 Full Text Search Engines 全文搜索引擎可以被看作是文档数据库的一个变种，他们可以提供灵活的可变的数据模式（scheme）以及自动索引。他们之间的不同点主要是，文档数据库用字段名做索引，而全文搜索引擎用字段值做索引。 Graph data models 图式数据库 可以被认为是这个进化过程中从 Ordered Key-Value 数据库发展过来的一个分支。图式数据库允许构建议图结构的数据模型。它和文档数据库有关系的原因是，它的很多实现允许value可以是一个map或是一个document。 NoSQL 数据模型摘要本文剩下的章节将向你介绍数据建模的技术实现和相关模式。但是，在介绍这些技术之前，先来一段序言： NoSQL 数据模型设计一般从业务应用的具体数据查询入手，而不是数据间的关系： 关系型的数据模型基本上是分析数据间的结构和关系。其设计理念是： “What answers do I have?” NoSQL 数据模型基本上是从应用对数据的存取方式入手，如：我需要支持某种数据查询。其设计理念是 “What questions do I have?” NoSQL 数据模型设计比关系型数据库需要对数据结构和算法的更深的了解。在这篇文章中我会和大家说那些尽人皆知的数据结构，这些数据结构并不只是被NoSQL使用，但是对于NoSQL的数据模型却非常有帮助。 数据冗余和反规格化是一等公民。 关系型数据库对于处理层级数据和图式数据非常的不方便。NoSQL用来解决图式数据明显是一个非常好的解决方案，几乎所有的NoSQL数据库可以很强地解决此类问题。这就是为什么这篇文章专门拿出一章来说明层级数据模型。 下面是NoSQL的分类表，也是我用来写这篇文章时做实践的产品： Key-Value 存储: Oracle Coherence, Redis, Kyoto Cabinet 类BigTable存储: Apache HBase, Apache Cassandra 文档数据库: MongoDB, CouchDB 全文索引: Apache Lucene, Apache Solr 图数据库: neo4j, FlockDB 概念技术 Conceptual Techniques这一节主要介绍NoSQL数据模型的基本原则。 （1）反规格化 Denormalization反规格化 Denormalization 可以被认为是把相同的数据拷贝到不同的文档或是表中，这样就可以简化和优化查询，或是正好适合用户的某中特别的数据模型。这篇文章中所说的绝大多数技术都或多或少地导向了这一技术。 总体来说，反规格化需要权衡下面这些东西： 查询数据量 /查询IO VS 总数据量。使用反规格化，一方面可以把一条查询语句所需要的所有数据组合起来放到一个地方存储。这意味着，其它不同不同查询所需要的相同的数据，需要放在别不同的地方。因此，这产生了很多冗余的数据，从而导致了数据量的增大。 处理复杂度 VS 总数据量. 在符合范式的数据模式上进行表连接的查询，很显然会增加了查询处理的复杂度，尤其对于分布式系统来说更是。反规格化的数据模型允许我们以方便查询的方式来存构造数据结构以简化查询复杂度。 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。 （2）聚合 Aggregates所有类型的NoSQL数据库都会提供灵活的Schema（数据结构，对数据格式的限制）： Key-Value Stores 和 Graph Databases 基本上来说不会Value的形式，所以Value可以是任意格式。这样一来，这使得我们可以任意组合一个业务实体的keys。比如，我们有一个用户帐号的业务实体，其可以被如下这些key组合起来： UserID_name, UserID_email, UserID_messages 等等。如果一个用户没有email或message，那么相应也不会有这样的记录。 BigTable 模型通过列集合来支持灵活的Schema，我们称之为列族（column family）。BigTable还可以在同一记录上出现不同的版本（通过时间戳）。 Document databases 文档数据库是一种层级式的“去Schema”的存储，虽然有些这样的数据库允许检验需要保存的数据是否满足某种Schema。 灵活的Schema允许你可以用一种嵌套式的内部数据方式来存储一组有关联的业务实体（陈皓注：类似于JSON这样的数据封装格式）。这样可以为我们带来两个好处。 最小化“一对多”关系——可以通过嵌套式的方式来存储实体，这样可以少一些表联结。 可以让内部技术上的数据存储更接近于业务实体，特别是那种混合式的业务实体。可能存于一个文档集或是一张表中。 下图示意了这两种好处。图中描给了电子商务中的商品模型（陈皓注：我记得我在“挑战无处不在”一文中说到过电商中产品分类数据库设计的挑战） 首先，所有的商品Product都会有一个ID，Price 和 Description。 然后，我们可以知道不同的类型的商品会有不同的属性。比如，作者是书的属性，长度是牛仔裤的属性。其些属性可能是“一对多”或是“多对多”的关系，如：唱片中的曲目。 接下来，我们知道，某些业务实体不可能使用固定的类型。如：牛仔裤的属性并不是所有的牌子都有的，而且，有些名牌还会搞非常特别的属性。 对于关系型数据库来说，要设计这样的数据模型并不简单，而且设计出来的绝对离优雅很远很远。而我们NoSQL中灵活的Schema允许你使用一个聚合 Aggregate (product) 可以建出所有不同种类的商品和他们的不同的属性： ![](NoSQL 数据建模技术/2017-05-29-18-37-32.png) *Entity Aggregation* 上图中我们可以比较关系型数据库和NoSQL的差别。但是我们可以看到在数据更新上，非规格化的数据存储在性能和一致性上会有很大的影响，这就是我们需要重点注意和不得不牺牲的地方。 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。 （3）应用层联结 Application Side Joins表联结基本上不被NoSQL支持。正如我们前面所说的，NoSQL是“面向问题”而不是“面向答案”的，不支持表联结就是“面向问题”的后果。表的联结是在设计时被构造出来的，而不是在执行时建造出来的。所以，表联结在运行时是有很大开销的（陈皓注：搞过SQL表联结的都知道笛卡尔积是什么东西，大可以在参看以前酷壳的“图解数据库表Joins”），但是在使用了 Denormalization 和 Aggregates 技术后，我们基本不用进行表联结，如：你们使用嵌套式的数据实体。当然，如果你需要联结数据，你需要在应用层完成这个事。下面是几个主要的Use Case： 多对多的数据实体关系——经常需要被连接或联结。 聚合 Aggregates 并不适用于数据字段经常被改变的情况。对此，我们需要把那些经常被改变的字段分到另外的表中，而在查询时我们需要联结数据。例如，我们有个Message系统可以有一个User实体，其包括了一个内嵌的Message实体。但是，如果用户不断在附加 message，那么，最好把message拆分到另一个独立的实体，但在查询时联结这User和Message这两个实体。如下图： ![](NoSQL 数据建模技术/2017-05-29-18-46-01.png) 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库， Graph Databases 图数据库。 通用建模技术 General Modeling Techniques在本书中，我们将讨论NoSQL中各种不同的通用的数据建模技术。 （4）原子聚合 Atomic Aggregates很多NoSQL的数据库（并不是所有）在事务处理上都是短板。在某些情况下，他们可以通过分布式锁技术或是应用层管理的MVCC技术来实现其事务性（陈皓注：可参看本站的“多版本并发控制(MVCC)在分布式系统中的应用”）但是，通常来说只能使用聚合Aggregates技术来保证一些ACID原则。 这就是为什么我们的关系型数据库需要有强大的事务处理机制——因为关系型数据库的数据是被规格化存放在了不同的地方。所以，Aggregates聚合允许我们把一个业务实体存成一个文档、存成一行，存成一个key-value，这样就可以原子式的更新了： ![](NoSQL 数据建模技术/2017-05-29-18-46-47.png) *Atomic Aggregates* 当然，原子聚合 Atomic Aggregates 这种数据模型并不能实现完全意义上的事务处理，但是如果支持原子性，锁，或 test-and-set 指令，那么， Atomic Aggregates 是可以适用的。 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。 （5）可枚举键 Enumerable Keys也许，对于无顺序的Key-Value最大的好处是业务实体可以被容易地hash以分区在多个服务器上。而排序了的key会把事情搞复杂，但是有些时候，一个应用能从排序key中获得很多好处，就算是数据库本身不提供这个功能。让我们来思考下email消息的数据模型： 一些NoSQL的数据库提供原子计数器以允许生一些连续的ID。在这种情况下，我们可以使用 userID_messageID 来做为一个组合key。如果我们知道最新的message ID，就可以知道前一个message，也可能知道再前面和后面的Message。 Messages可以被打包。比如，每天的邮件包。这样，我们就可以对邮件按指定的时间段来遍历。 适用性: Key-Value Store 键值对数据库。 （6）降维 Dimensionality ReductionDimensionality Reduction 降维是一种技术可以允许把一个多维的数据映射成一个Key-Value或是其它非多给的数据模型。 传统的地理位置信息系统使用一些如“四分树QuadTree” 或 “R-Tree” 来做地理位置索引。这些数据结构的内容需要被在适当的位置更新，并且，如果数据量很大的话，操作成本会很高。另一个方法是我们可以遍历一个二维的数据结构并把其扁平化成一个列表。一个众所周知的例子是Geohash（地理哈希）。一个Geohash使用“之字形”的路线扫描一个2维的空间，而且遍历中的移动可以被简单地用0和1来表示其方向，然后在移动的过程中产生0/1串。下图展示了这一算法：（陈皓注：先把地图分成四份，经度为第一位，纬度为第二位，于是左边的经度是0，右边的是1，纬度也一样，上面是为1，下面的为0，这样，经纬度就可以组合成01，11，00，10这四个值，其标识了四块区域，我们可以如此不断的递归地对每个区域进行四分，然后可以得到一串1和0组成的字串，然后使用0-9，b-z 去掉（去掉a, i, l, o）这32个字母进行base32编码得到一个8个长度的编码，这就是Geohash的算法） ![](NoSQL 数据建模技术/2017-05-29-18-47-55.png) *Geohash Index* Geohash的最强大的功能是使用简单的位操作就可以知道两个区域间的距离，就像图中所示（陈皓：proximity框着的那两个，这个很像IP地址了）。Geohash把一个二维的坐标生生地变成了一个一维的数据模型，这就是降维技术。BigTable的降维技术参看到文章后面的 [6.1]。更多的关于Geohash和其它技术可以参看 [6.2] 和 [6.3]。 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。 （7）索引表 Index TableIndex Table 索引表是一个非常直白的技术，其可以你在不支持索引的数据库中得到索引的好处。BigTable是这类最重要的数据库。这需要我们维护一个有相应存取模式的特别表。例如，我们有一个主表存着用户帐号，其可以被UserID存取。某查询需要查出某个城市里所有的用户，于是我们可以加入一张表，这张表用城市做主键，所有和这个城市相关的UserID是其Value，如下所示： ![](NoSQL 数据建模技术/2017-05-29-18-48-28.png) *Index Table Example* 可见，城市索引表的需要和对主表用户表保持一致性，因此，主表的每一个更新可能需要对索引表进行更新，不然就是一个批处理更新。无论哪个方式，这都会损伤一些性能，因为需要保持一致性。 Index Table 索引表可以被认为是关系型数据库中的视图的等价物。 适用性: BigTable 数据库。 （8）键组合索引 Composite Key IndexComposite key 键组合是一个很常用的技术，对此，当我们的数据库支持键排序时能得到极大的好处。Composite key组合键的拼接成为第二排序字段可以让你构建出一种多维索引，这很像我们之前说过的 Dimensionality Reduction 降维技术。例如，我们需要存取用户统计。如果我们需要根据不同的地区来统计用户的分布情况，我们可以把Key设计成这样的格式 (State:City:UserID)，这样一来，就使得我们可以通过State到City来按组遍历用户，特别是我们的NoSQL数据库支持在key上按区查询（如：BigTable类的系统）： SELECT Values WHERE state="CA:*" SELECT Values WHERE city="CA:San Francisco*" ![](NoSQL 数据建模技术/2017-05-29-18-49-17.png) *Composite Key Index* 适用性: BigTable 数据库。 （9）键组合聚合 Aggregation with Composite KeysComposite keys 键组合技术并不仅仅可以用来做索引，同样可以用来区分不用的类型的数据以支持数据分组。考虑一个例子，我们有一个海量的日志数组，这个日志记录了互联网上的用户的访问来源。我们需要计算从某一网站过来的独立访客的数量，在关系型数据库中，我们可能需要下面这样的SQL查询语句： SELECT count(distinct(user_id)) FROM clicks GROUP BY site 我们可以在NoSQL中建立如下的数据模型： ![](NoSQL 数据建模技术/2017-05-29-18-50-06.png) *Counting Unique Users using Composite Keys* 这样，我们就可以把数据按UserID来排序，我们就可以很容易把同一个用户的数据（一个用户并不会产生太多的event）进行处理，去掉那些重复的站点（使用hash table或是别的什么）。另一个可选的技术是，我们可以对每一个用户建立一个数据实体，然后把其站点来源追加到这个数据实体中，当然，这样一来，数据的更新在性能相比之下会有一定损失。 适用性: Ordered Key-Value Store 排序键值对数据库， BigTable风格的数据库。 （10）反转搜索 Inverted Search – 直接聚合 Direct Aggregation这个技术更多的是数据处理技术，而不是数据建模技术。尽管如此，这个技术还是会影响数据模型。这个技术最主要的想法是使用一个索引来找到满足某条件的数据，但是把数据聚合起需要使用全文搜索。还是让我们来说一个示例。还是用上面那个例子，我们有很多的日志，其中包括互联网用户和他们的访问来源。让我们假定每条记录都有一个UserID，还有用户的种类 (Men, Women, Bloggers, 等)，以及用户所在的城市，和访问过的站点。我们要干的事是，为每个用户种类找到满足某些条件（访问源，所在城市，等）的的独立用户。 很明显，我们需要搜索那些满足条件的用户，如果我们使用反转搜索，这会让我们把这事干得很容易，如： {Category -&gt; [user IDs]} 或 {Site -&gt; [user IDs]}。使用这样的索引， 我们可以取两个或多个UserID要的交集或并集（这个事很容易干，而且可以干得很快，如果这些UserID是排好序的）。但是，我们要按用户种类来生成报表会变得有点麻烦，因为我们用语句可能会像下面这样 SELECT count(distinct(user_id)) ... GROUP BY category 但这样的SQL很没有效率，因为category数据太多了。为了应对这个问题，我们可以建立一个直接索引 {UserID -&gt; [Categories]} 然后我们用它来生成报表： ![](NoSQL 数据建模技术/2017-05-29-18-51-39.png) *Counting Unique Users using Inverse and Direct Indexes* 最后，我们需要明白，对每个UserID的随机查询是很没有效率的。我们可以通过批查询处理来解决这个问题。这意味着，对于一些用户集，我们可以进行预处理（不同的查询条件）。 适用性: Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。 层级式模型 Hierarchy Modeling Techniques（11）树形聚合Tree Aggregation树形或是任意的图（需反规格化）可以被直接打成一条记录或文档存放。 当树形结构被一次性取出时这会非常有效率（如：我们需要展示一个blog的树形评论） 搜索和任何存取这个实体都会存在问题。 对于大多数NoSQL的实现来说，更新数据都是很不经济的（相比起独立结点来说） ![](NoSQL 数据建模技术/2017-05-29-18-52-26.png) *Tree Aggregation* 适用性: Key-Value 键值对数据库, Document Databases 文档数据库 （12）邻接列表 Adjacency ListsAdjacency Lists 邻接列表是一种图 – 每一个结点都是一个独立的记录，其包含了 所有的父结点或子结点。这样，我们就可以通过给定的父或子结点来进行搜索。当然，我们需要通过hop查询遍历图。这个技术在广度和深度查询，以及得到某个结点的子树上没有效率。 适用性: Key-Value 键值对数据库, Document Databases 文档数据库 （13）Materialized PathsMaterialized Paths 可以帮助避免递归遍历（如：树形结构）。这个技术也可以被认为是反规格化的一种变种。其想法是为每个结点加上父结点或子结点的标识属性，这样就可以不需要遍历就知道所有的后裔结点和祖先结点了： ![](NoSQL 数据建模技术/2017-05-29-18-52-56.png) *Query Materialized Paths using RegExp* 适用性: Key-Value 键值对数据库, Document Databases 文档数据, Search Engines 搜索引擎 （14）嵌套集 Nested SetsNested sets 嵌套集是树形结构的标准技术。它被广泛地用在了关系性数据库中，它完全地适用于 Key-Value 键值对数据库 和 Document Databases 文档数据库。这个技术的想法是把叶子结点存储成一个数组，并通过使用索引的开始和结束来映射每一个非叶子结点到一个叶子结点集，就如下图所示一样： ![](NoSQL 数据建模技术/2017-05-29-18-53-22.png) *Modeling of eCommerce Catalog using Nested Sets* 这样的数据结构对于immutable data不变的数据 有非常不错的效率，因为其点内存空间小，并且可以很快地找出所有的叶子结点而不需要树的遍历。尽管如此，在插入和更新上需要很高的性能成本，因为新的叶子结点需要大规模地更新索引。 适用性: Key-Value Stores 键值数据库, Document Databases 文档数据库 （15）嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names搜索引擎基本上来说和扁平文档一同工作，如：每一个文档是一个扁平的字段和值的例表。这种数据模型的用来把业务实体映射到一个文本文档上，如果你的业务实体有很复杂的内部结构，这可能会变得很有挑战。一个典型的挑战是把一个有层级的文档映映射出来。例如，文档中嵌套另一个文档。让我们看看下面的示例： ![](NoSQL 数据建模技术/2017-05-29-18-54-47.png) *Nested Documents Problem* 上面的每一个业务实体代码一种简历。其包括了人名和一个技能列表。我把这个层级文档映射成一个文本文档，一种方法是创建 Skill 和 Level 字段。这个模型可以通过技术或是等级来搜索一个人，而上图标注的那样的组合查询则会失败。（陈皓注：因为分不清Excellent是否是Math还是Poetry上的） 在引用中的 [4.6] 给出了一种解决方案。其为每个字段都标上数字 Skill_i 和 Level_i，这样就可以分开搜索每一个对（下图中使用了OR来遍历查找所有可能的字段）: ![](NoSQL 数据建模技术/2017-05-29-18-55-02.png) *Nested Document Modeling using Numbered Field Names* 这样的方式根本没有扩展性，对于一些复杂的问题来说只会让代码复杂度和维护工作变大。 适用性: Search Engines 全文搜索 （16）嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries在附录 [4.6]中给出了这个技术用来解决扁平层次文档。它用邻近的查询来限制可被查询的单词的范围。下图中，所有的技能和等级被放在一个字段中，叫 SkillAndLevel，查询中出现的 “Excellent” 和 “Poetry” 必需一个紧跟另一个： ![](NoSQL 数据建模技术/2017-05-29-18-55-33.png) *Nested Document Modeling using Proximity Queries* 附录 [4.3] 中讲述了这个技术被用在Solr中的一个成功案例。 适用性: Search Engines 全文搜索 （17）图结构批处理 Batch Graph ProcessingGraph databases 图数据库，如 neo4j 是一个出众的图数据库，尤其是使用一个结点来探索邻居结点，或是探索两个或少量结点前的关系。但是处理大量的图数据是很没有效率的，因为图数据库的性能和扩展性并不是其目的。分布式的图数据处理可以被 MapReduce 和 Message Passing pattern 来处理。如： 在我前一篇的文章中的那个示例。这个方法可以让 Key-Value stores, Document databases, 和 BigTable-style databases 适合于处理大图。 Applicability: Key-Value Stores, Document Databases, BigTable-style Databases 参考Finally, I provide a list of useful links related to NoSQL data modeling: Key-Value Stores: http://www.devshed.com/c/a/MySQL/Database-Design-Using-KeyValue-Tables/ http://antirez.com/post/Sorting-in-key-value-data-model.html http://stackoverflow.com/questions/3554169/difference-between-document-based-and-key-value-based-databases http://dbmsmusings.blogspot.com/2010/03/distinguishing-two-major-types-of_29.html BigTable-style Databases: http://www.slideshare.net/ebenhewitt/cassandra-datamodel-4985524 http://www.slideshare.net/mattdennis/cassandra-data-modeling http://nosql.mypopescu.com/post/17419074362/cassandra-data-modeling-examples-with-matthew-f-dennis http://s-expressions.com/2009/03/08/hbase-on-designing-schemas-for-column-oriented-data-stores/ http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable Document Databases: http://www.slideshare.net/mongodb/mongodb-schema-design-richard-kreuters-mongo-berlin-preso http://www.michaelhamrah.com/blog/2011/08/data-modeling-at-scale-mongodb-mongoid-callbacks-and-denormalizing-data-for-efficiency/ http://seancribbs.com/tech/2009/09/28/modeling-a-tree-in-a-document-database/ http://www.mongodb.org/display/DOCS/Schema+Design http://www.mongodb.org/display/DOCS/Trees+in+MongoDB http://blog.fiesta.cc/post/11319522700/walkthrough-mongodb-data-modeling Full Text Search Engines: http://www.searchworkings.org/blog/-/blogs/query-time-joining-in-lucene http://www.lucidimagination.com/devzone/technical-articles/solr-and-rdbms-basics-designing-your-application-best-both http://blog.griddynamics.com/2011/07/solr-experience-search-parent-child.html http://www.lucidimagination.com/blog/2009/07/18/the-spanquery/ http://blog.mgm-tp.com/2011/03/non-standard-ways-of-using-lucene/ http://www.slideshare.net/MarkHarwood/proposal-for-nested-document-support-in-lucene http://mysolr.com/tips/denormalized-data-structure/ http://sujitpal.blogspot.com/2010/10/denormalizing-maps-with-lucene-payloads.html http://java.dzone.com/articles/hibernate-search-mapping-entit Graph Databases: http://docs.neo4j.org/chunked/stable/tutorial-comparing-models.html http://blog.neo4j.org/2010/03/modeling-categories-in-graph-database.html http://skillsmatter.com/podcast/nosql/graph-modelling http://www.umiacs.umd.edu/~jimmylin/publications/Lin_Schatz_MLG2010.pdf Demensionality Reduction: http://www.slideshare.net/mmalone/scaling-gis-data-in-nonrelational-data-stores http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves http://www.trisis.co.uk/blog/?p=1287 （全文完） 转载自（http://coolshell.cn/articles/7270.html）]]></content>
      <tags>
        <tag>nosql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-display]]></title>
    <url>%2F2017%2F05%2F28%2Fcss-display%2F</url>
    <content type="text"><![CDATA[在盒子模型中每个盒子都可以被用于不同的显示方式，其中控制显示方式的属性是display。如同&lt;tab&gt;和&lt;p&gt;其显示的方式是有很大区别的，我们可以通过display来进行盒子显示方式的改变。 display 属性值属性值: 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值）。 list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。 table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。 table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;）。 table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt;和 &lt;th&gt;）。 table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;）。 inherit 规定应该从父元素继承 display 属性的值。 常用的用加粗表示 display 实例代码样本： &lt;html> &lt;head> &lt;meta charset="utf-8"> &lt;title>测试display属性值&lt;/title> &lt;style> body{border: 1px solid;} p { border: 1px solid red; display: &lt;属性值>; &lt;!--测试几个常用的值--> } &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li> &lt;p>这是第一个元素。 &lt;br> 换行重新来一段！！！ &lt;/p> &lt;/li> &lt;li> &lt;p>这是第二个标签，第二个元素。&lt;/p> &lt;/li> &lt;/ul> &lt;/body> &lt;/html> block样式： inline样式： inline-block样式： list-item样式： table样式： inline-table样式：]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QThread线程]]></title>
    <url>%2F2017%2F05%2F23%2FQThread%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[QTherd 线程（未完待续） 创建thread常用的创建线程的方法有4种 分别是： 继承QThread 继承QRunnable 使用moveToThread 使用QtConcurrent::run 重中之重： 由于run()可以在运行的时候直接调用exec()对线程进行死循环。 一定要使用moveToThread+信号槽机制，可以节省很多东西，非常方便，这个是最新的用法！！！一定要使用moveToThread+信号槽机制，可以节省很多东西，非常方便，这个是最新的用法！！！一定要使用moveToThread+信号槽机制，可以节省很多东西，非常方便，这个是最新的用法！！！ 这样做完全可以通过： QProjet的子类来设计运行代码。 通过信号槽机制来进行QProjet的子类代码的开始、暂停、结束。 用moveToThread来装载QProject的子类，对QThread进行单独控制。 详见：使用moveToThread 继承QThread继承QThread，这应该是最常用的方法了。我们可以通过重写虚函数void QThread::run ()实现我们自己想做的操作，实现新建线程的目的。如果需要让函数一直运行下去，可以在函数后面添加exec()。 下面一个例子给出了在应用程序中除了主线程外，还提供了线程A和B。如果单击窗口中的按钮“Start A”，Qt的控制台就会连续输出字母“A”，此时按钮“Start A”被刷新为“Stop A”。再单击按钮“Start B”，控制台会交替输出字母“A”和“B”。如果再单击按钮“Stop A”，则控制台只输出字母“B”。如下图所示： 程序结构 thread.h代码 #define THREAD_H #include &lt;QThread> #include &lt;iostream> class Thread : public QThread{ Q_OBJECT public: Thread(); void setMessage(QString message); void stop(); protected: void run(); void printMessage(); private: QString messageStr; volatile bool stopped; }; #endif 注： stopped被声明为易失性变量（volatile variable，断电或中断时数据丢失而不可再恢复的变量类型），这是因为不同的线程都需要访问它，并且我们也希望确保它能在任何需要的时候都保持最新读取的数值。如果省略关键字volatile，则编译器就会对这个变量的访问进行优化，可能导致不正确的结果。 thread.cpp代码 #include "thread.h" #include &lt;QDebug> Thread::Thread(){ stopped = false; } void Thread::run() { while(!stopped) { printMessage();{ stopped = false; } void Thread::stop() { stopped = true; } void Thread::setMessage(QString message){ messageStr = message; } void Thread::printMessage(){ Debug()&lt;&lt;messageStr; sleep(1); } 注： QTread提供了一个terminate()函数，该函数可以再一个线程还在运行的时候就终止它的执行，但不推荐用terminate()，因为terminate()不会立刻终止这个线程，该线程何时终止取决于操作系统的调度策略，也就是说，它可以随时停止线程执行而不给这个线程自我清空的机会。更安全的方法是用stopped变量和stop()函数，如例子所示。 调用setMessage()让第一个线程每隔1秒打印字母“A”，而让第二个线程每隔1秒打印字母“B”。 线程会因为调用printf()而持有一个控制I/O的锁，多个线程同时调用printf()在某些情况下回造成控制台输出阻塞，而用qDebug()作为控制台输出一般不会出现上述问题。 threaddialog.h代码 #ifndef THREADDIALOG_H #define THREADDIALOG_H #include &lt;QPushButton> #include &lt;QDialog> #include &lt;QCloseEvent> #include "thread.h" class ThreadDialog : public QDialog { Q_OBJECT public: ThreadDialog(QWidget *parent=0); protected: void closeEvent(QCloseEvent *event); private slots: void startOrStopThreadA(); void startOrStopThreadB(); void close(); private: Thread threadA; Thread threadB; QPushButton *threadAButton; QPushButton *threadBButton; QPushButton *quitButton; }; #endif // THREADDIALOG_H threaddialog.cpp代码 #include "threaddialog.h" ThreadDialog::ThreadDialog(QWidget *parent) : QDialog(parent) { threadA.setMessage("A"); threadB.setMessage("B"); threadAButton = new QPushButton(tr("Start A"), this); threadAButton->setGeometry(10, 30, 80, 30); threadBButton = new QPushButton(tr("Start B"),this); threadBButton->setGeometry(110, 30, 80, 30); quitButton = new QPushButton(tr("Quit"), this); quitButton->setGeometry(210, 30, 80, 30); quitButton->setDefault(true); connect(threadAButton, SIGNAL(clicked()), this,SLOT(startOrStopThreadA())); connect(threadBButton, SIGNAL(clicked()), this,SLOT(startOrStopThreadB())); connect(quitButton, SIGNAL(clicked()), this, SLOT(close())); } void ThreadDialog::startOrStopThreadA() { if(threadA.isRunning()) { threadAButton->setText(tr("Stop A")); threadA.stop(); threadAButton->setText(tr("Start A")); } else { threadAButton->setText(tr("Start A")); threadA.start(); threadAButton->setText(tr("Stop A")); } } void ThreadDialog::startOrStopThreadB() { if(threadB.isRunning()) { threadBButton->setText(tr("Stop B")); threadB.stop(); threadBButton->setText(tr("Strat B")); } else { threadBButton->setText(tr("Start B")); threadB.start(); threadBButton->setText(tr("Stop B")); } } void ThreadDialog::closeEvent(QCloseEvent *event) { 55 threadA.stop(); threadB.stop(); threadA.wait(); threadB.wait(); event->accept(); } void ThreadDialog::close() { exit(0); } 注： startOrStopA的逻辑是：当单击A的按钮时，如果系统判断到有线程A在运行中，就把A的按钮刷新为“Stop A”，表示可以进行stop A的动作，并停止线程A的运行，再将A的按钮刷新为“Start A”。否则，如果线程A没有运行，就把按钮刷新为表示可以运行的“Start A”，启动线程A，然后将A按钮刷新为“Stop A”。 当不用Qt设计器时，new一个button出来，需要指定一个父类，比如this，否则运行程序，窗口里没有按钮。 new了多个按钮或控件，需要用setGeometry来确定它们的大小和位置，否则前面的被后面的覆盖，最终看到的是最后一个按钮。setGeometry的前2个参数是相对于窗口的坐标位置，后两个参数是按钮的长宽。 单击Quit或关闭窗口，就停止所有正在运行的线程，并且在调用函数QCloseEvent::accept()之前等待它们完全结束，这样就可以确保应用程序是以一种原始清空的状态退出的。 如果没有62~65行的重新定义close函数，使进程完全退出。否则点击Quit按钮或叉号退出窗口后，进程依然驻留在系统里。 main.cpp代码 #include "threaddialog.h" #include &lt;QApplication> int main(int argc, char *argv[]) { QApplication app(argc, argv); ThreadDialog *threaddialog = new ThreadDialog; threaddialog->exec(); return app.exec(); } 注： 在GUI程序中，主线程也被称为GUI线程，因为它是唯一一个允许执行GUI相关操作的线程。必须在创建一个QThread之前创建QApplication对象。 继承QRunnableQrunnable是所有可执行对象的基类。我们可以继承Qrunnable，并重写虚函数void QRunnable::run () 。我们可以用QThreadPool让我们的一个QRunnable对象在另外的线程中运行，如果autoDelete()返回true(默认)，那么QThreadPool将会在run()运行结束后自动删除Qrunnable对象。可以调用void QRunnable::setAutoDelete ( bool autoDelete )更改auto-deletion标记。需要注意的是，必须在调用QThreadPool::start()之前设置，在调用QThreadPool::start()之后设置的结果是未定义的。 例子： class Runnable:publicQRunnable { //Q_OBJECT 注意了，Qrunnable不是QObject的子类。 public: Runnable(); ~Runnable(); voidrun(); protected: private: }; Runnable::Runnable():QRunnable() { } Runnable::~Runnable() { cout&lt;&lt;"~Runnable()"&lt;&lt;endl; } void Runnable::run() { cout&lt;&lt;"Runnable::run()thread :"&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; cout&lt;&lt;"dosomething ...."&lt;&lt;endl; } int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); cout&lt;&lt;"mainthread :"&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; Runnable runObj; QThreadPool::globalInstance()->start(&amp;runObj); returna.exec(); } 由结果可看出，run()确实是在不同于主线程的另外线程中运行的，而且在运行结束后就调用了析构函数，因为默认是可以自动被销毁的。 我们可以对同一个对象多次调用QThreadPool::start()，如果是可以自动被销毁的，Qrunnable对象会在最后一个线程离开了run函数之后才被销毁的。 int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); cout&lt;&lt;"mainthread :"&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; Runnable runObj; QThreadPool::globalInstance()->start(&amp;runObj); QThreadPool::globalInstance()->start(&amp;runObj); QThreadPool::globalInstance()->start(&amp;runObj); returna.exec(); } 我三次调用QThreadPool::globalInstance()-&gt;start(&amp;runObj);但是在三次都执行完之后才运行析构函数。 这种新建线程的方法的最大的缺点就是：不能使用Qt的信号—槽机制，因为Qrunnable不是继承自QObject。所以我们要想知道线程是否运行结束或获取运行结果可能会比较麻烦。还有就是我们不能直接调用run()启动线程，必须借助于QthreadPool。 但是这种方法的好处就是，可以让QThreadPool来管理线程，QThreadPool会自动的清理我们新建的Qrunnable对象。 使用moveToThread首先我们必须实现继承QObject的一个类，实现我们想要的功能。 class Worker:publicQObject { Q_OBJECT public: Worker(); ~Worker(); protected slots: void fun1(); void fun2(); private: }; Worker::Worker():QObject() { } Worker::~Worker() { } void Worker::fun1() { cout&lt;&lt;"Worker::fun1() thread : "&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; } 接着创建一个对象，并调用:moveToThread ( QThread * targetThread )，让对象在新的线程中运行。 int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); cout&lt;&lt;"mainthread :"&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; QThread thread; Worker work; thread.start(); //注意记得启动线程 work.moveToThread(&amp;thread); //由于不能直接调用worker //的函数，所以一般用信号触发调用 QTimer::singleShot(0,&amp;work,SLOT(fun1())); QTimer::singleShot(0,&amp;work,SLOT(fun1())); returna.exec(); } 这样就能让fun1()和fun2()都运行在thread线程中了。 worning需要注意的是：在work 的函数结束运行前，thread不能被析构。Thread的生命期不能小于work。否则的话程序就好崩掉了。 像下面的代码肯定是不行的。 void Dialog::startWork() { QThread thread; Worker*work = new Worker; thread.start(); work->moveToThread(&amp;thread); QTimer::singleShot(0,work,SLOT(fun1())); QTimer::singleShot(0,work,SLOT(fun2())); } 所以thread 必须是new出来的。但是这样的话，就感觉有点麻烦，我们要同时管理thread和work，因为都是new 出来，我们需要负责清理。为了避免这样的麻烦，我想到的方法是，在work类中添加一个QThread成员。 class Worker:publicQObject { Q_OBJECT public: Worker(); ~Worker(); protected slots: voidfun1(); voidfun2(); private: QThread m_thread; }; Worker::Worker():QObject() { m_thread.start(); this->moveToThread(&amp;m_thread); } 这样我们在用的时候只需要newwork就行了。 使用QtConcurrent::run其实前面也有用到QtConcurrent::run启动新线程了。QtConcurrent命名空间提供了很多方法可以实现并发编程，这个以后再深入探讨了，这里只是大概讲一下启动线程。还是用上面的worker代码作为例子： void Worker::start() { QtConcurrent::run(this,&amp;Worker::fun1); QtConcurrent::run(this,&amp;Worker::fun2); } QtConcurrent::run是个模板函数，有很多种形式，我们也可以让全局的函数允许在另外的线程中。 void printMes(char*mes) { cout&lt;&lt;"pprintMes(char*mes) thread : "&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; cout&lt;&lt;mes&lt;&lt;endl; } int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); cout&lt;&lt;"mainthread :"&lt;&lt;QThread::currentThreadId()&lt;&lt;endl; char *mes= "hello world"; QtConcurrent::run(printMes,mes); returna.exec(); } 小贴士 Thread的生命期不能小于Thread中的程序，意思就是在运行函数析构之前不能析构Thread（小心那些会自动回收的东西）。 可以在子类中直接实例化1个QThread，然后在子类中创建线程，到时候只需要回收子类的资源就可以了。 子类不可以指定父类，不然子类的线程无法单独开辟（由于没有指定父类，注意垃圾回收哦）。 QThread会通知你触发了一个信号当线程finished() 时，或者使用isFinished() 和isRunning() 来查询线程的状态。 terminate() 有毒，不要使用！可以通过调用exit() 或quit() 来停止线程。 QThread中还提供了静态的、平台独立的休眠功能：sleep() 、msleep() 、usleep() 允许秒，毫秒和微秒来区分，这些函数在Qt5.0中被设为public。 一般情况下sleep() 函数应该不需要，因为Qt是一个事件驱动型框架。关心监听信号finished()，而不是wait() 。 一个线程是否一直执行 可以通过2个方式解决：1.在虚函数QThread::run() 中添加QThread::exec() ，这个程序会在线程中循环执行，退出线程使用quit() 。2.while语句，退出线程使用自己写的stopped 变量和stop() 函数（见示例 继承QThread）。 最新的qt在执行run()的时候就会执行exec()。 从Qt4.8起，可以释放运行刚刚结束的线程对象，通过连接finished() 信号到 QObject::deleteLater() 。使用wait()来阻塞调用的线程，直到其他线程执行完毕（或者直到指定的时间过去）。connect(workerThread, &amp;WorkerThread::finished,workerThread, &amp;QObject::deleteLater); 线程的同步 （锁）QMutexQMutex 提供相互排斥的锁，或互斥量。QMutex提供了lock和Unlock函数，如果 一个已经锁定 这个互斥量，只有这个线程unlock后其它线程才可以访问。 #ifndef MYTHREAD_H #define MYTHREAD_H #include &lt;QThread> class QMutex; class MyThread : public QThread { Q_OBJECT private: QMutex qm; bool stop; public: explicit MyThread(QObject *parent = 0); void run(); void SetFlg(bool flg); signals: public slots: }; #endif // MYTHREAD_H #include "mythread.h" #include&lt;QDebug> #include&lt;QMutex> MyThread::MyThread(QObject *parent) : QThread(parent) { stop = false; } void MyThread::SetFlg(bool flg) { qm.lock(); stop=flg; qm.unlock(); } void MyThread::run() { for(int i=0;i&lt;1000;i++) { qm.lock(); if(stop) { qm.unlock(); break; } qDebug()&lt;&lt;i; QThread::sleep(1); qm.unlock(); } } #include &lt;QCoreApplication> #include "myobject.h" #include &lt;QThread> #include&lt;QDebug> #include "mythread.h" int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); MyThread myThread; myThread.start(); QThread::sleep(10); myThread.SetFlg(true); return a.exec(); } 使用QMutex时要小心因为如果 lock()后没有unlock()会导致死锁别的线程就永远也不能访问资源了Qt提供了QMutexLocker来解决这个问题修改我们的app文件 #include "mythread.h" #include&lt;QDebug> #include&lt;QMutex>\ #include&lt;QMutexLocker> MyThread::MyThread(QObject *parent) : QThread(parent) { stop = false; } void MyThread::SetFlg(bool flg) { QMutexLocker locker(&amp;qm); stop=flg; } void MyThread::run() { QMutexLocker locker(&amp;qm); for(int i=0;i&lt;1000;i++) { if(stop) { break; } qDebug()&lt;&lt;i; QThread::sleep(1); } } QMutexLocker会自己unluckQMutexLocker也提供了一个mutex()成员函数返回QMutexLocker操作的互斥量。对于需要访问互斥量是十分有用的，比如QWaitCondition::wait()。QReadWirterLock用mutext进行线程同步有一个问题某个时刻只许一个线程访问资源如果同时有多个线程对共享资源进行访问，同时有写操作线程那么这种情况下采用mutex就会成为程序的瓶颈。使用QReadWriteLock来实现多线程读操作，一个线程写操作，写线程执行时会阻塞所有的读线程，而读线程运行不需要进行同步 QReadWriteLock lock; void ReaderThread::run() { ... lock.lockForRead(); read_file(); lock.unlock(); ... } void WriterThread::run() { ... lock.lockForWrite(); write_file(); lock.unlock(); ... } QreadLocker和QWriteLocker类是对QReadWirterLock 的简化它们会自动unluck(); QReadWriteLock lock; QByteArray readData() { QReadLocker locker(&amp;lock); ... return data; } 相当于QReadWirterLock 的写法如下 QReadWriteLock lock; QByteArray readData() { lock.lockForRead(); ... lock.unlock(); return data; } 线程的异步# ##]]></content>
      <tags>
        <tag>qt</tag>
        <tag>c++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WindowFlags来设置窗口的样式]]></title>
    <url>%2F2017%2F05%2F23%2FWindowFlags%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在qt中可以用WindowFlags来设置窗口的样式，用flags的值来进行窗口的设置，如果某一窗口设置为无状态栏且无标题，在退出时： 重新退出按钮。 父窗口关闭时，子窗口自动退出进程。 exit(0)可以直接终止程序close()只能关闭窗口 下面我们主要讲解父窗口关闭时，子窗口自动退出进程。 Qt窗体关闭时,如何自动销毁窗体类对象代码实例： //标题 Qt::WindowFlags flags = Qt::Dialog; //flags |= Qt::WindowCloseButtonHint; //flags |= Qt::WindowMinimizeButtonHint; //flags |= Qt::WindowStaysOnTopHint; //窗口顶置 //flags |= Qt::WindowCloseButtonHint; flags |= Qt::FramelessWindowHint; //窗口无标题 flags |= Qt::Tool; //转成后台程序,在状态栏无显示 //flags |= Qt::X11BypassWindowManagerHint; setWindowFlags(flags); //把所选择的flags加载 //QApplication::setQuitOnLastWindowClosed(false); //setAttribute(Qt::WA_DeleteOnClose, false); //this->setAttribute(Qt::WA_TranslucentBackground); this->setAttribute(Qt::WA_QuitOnClose, true); 当我们创建一个窗口时，如果这个窗口是一个顶级窗口，准确地说是w.windowFlags().testFlag(Qt.Window) is True的窗口，Qt会自动附加一个Qt::WA_QuitOnClose属性。它的意思是，窗口被关闭了，qApp.lastWindowClose信号会被触发。 默认情况下，qApp接收到此信号后会退出程序，这个行为相当于在初始化程序时： qApp.lastWindowClosed.connect(qApp.quit) 要修改这个默认行为，可以设置QApplication的quitOnLastWindowClosed属性，比如： QApplication::setQuitOnLastWindowClosed(False)//拒绝发送 比如这样设置 setAttribute(Qt::WA_QuitOnClose,true); QApplication::setQuitOnLastWindowClosed(false); 在关闭时，窗口关闭的信号还是无法发送。。。相当于允许发送信号，但是信号本身却拒绝发送。 Qt提供了一个简便的办法，只要将窗口的Qt::WA_DeleteOnClose属性设置为true，Qt会自动帮我们销毁这个窗口。 如果setAttribute(Qt::WA_DeleteOnClose, false)，那么窗口只是hide()，意味着还是在进程里面霸占着资源，并没有释放。 Qt::WA_DeleteOnClose如果我们在程序中通过 new 的方式创建一个窗口，可以给该窗口设置Qt::WA_DeleteOnClose属性。这样在关闭这个窗口时Qt能够自动回收该窗口所占用的资源，这样能够及时回收无效的资源，有用利于节约内存空间。 通过不断打开窗口，再关闭所有打开的窗口。在任务管理器中对比该应用程序所占用的资源大小。 设置了Qt::WA_DeleteOnClose属性 未设置 Qt::WA_DeleteOnClose属性 从上两幅图中可以看到，在不停地打开窗口，程序占用内存不断增加，而在所有窗口关闭的过程中，设置了Qt::WA_DeleteOnClose属性的情况下我们发现关闭的窗口所占用的内存资源在不断回收，全部关闭后恢复到之前的状态。而没有设置Qt::WA_DeleteOnClose属性的情况下我们发现关闭的窗口所占用的内存资源并没有减少。这就说明，关闭的窗口内存未被回收。 由此看来Qt::WA_DeleteOnClose属性的重要性了。 参考： http://blog.163.com/qimo601@126/blog/static/1582209320130105113647/http://www.cnblogs.com/findumars/p/6201221.html]]></content>
      <tags>
        <tag>qt</tag>
        <tag>c++</tag>
        <tag>windowflags</tag>
        <tag>窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt动画效果，特效实现QPropertyAnimation，QGraphicsEffect]]></title>
    <url>%2F2017%2F05%2F23%2FQt%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%8C%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0QPropertyAnimation%EF%BC%8CQGraphicsEffect%2F</url>
    <content type="text"><![CDATA[主要讲了qt的动画和特效，主要应用在弹窗动画上，很多时候都会用到，主要用到2个类，QPropertyAnimation和QGraphicsEffect， 下面分开介绍这2个类。 QGraphicsEffect(特效)QGraphicsEffect的4个子类 QGraphicsBlurEffect QGraphicsColorizeEffect QGraphicsDropShadowEffect QGraphicsOpacityEffect QGraphicsBlurEffect该类用应产生模糊效果。 主要函数： setBlurRadius(qreal blurRadius) //用于控制图形元素的模糊度，数值越大越模糊。使用该类例子如下：QGraphicsBlurEffect *e0 = new QGraphicsBlurEffect(this); e0->setBlurRadius(0.2); item[0]->setGraphicsEffect(e1); //item[0]为QGraphicsItem指针 QGraphicsColorizeEffect该类提供了使用另外一种颜色对当前图形的一种着色功能。 主要函数： setColor(QColor) //指定了着色。 setStrength (qreal strength) //指定了着色和着色强度。使用该类例子如下:QGraphicsColorizeEffect *e1 = new QGraphicsColorizeEffect(this); e1->setColor(QColor(0,0,192)); item[1]->setGraphicsEffect(e1); QGraphicsDropShadowEffect该类提供了图形元素的阴影效果。用于增加立体感。 主要设置函数有3个： setColor() //用于设定阴影的颜色。 setBlurRadius() //用于设定阴影的模糊度。 setOffset (qreal dx,qreal dy) //用于设定在哪个方向产生阴影效果，如果dx为负数，则阴影在图形元素的左边。使用该类例子如下:QGraphicsDropShadowEffect *e2 = new QGraphicsDropShadowEffect(this); e2->setOffset(8,8); item[2]->setGraphicsEffect(e2); QGraphicsOpacityEffect该类用于图形元素的透明效果。 主要函数是： setOpacity(qreal opacity) //用于设置透明度，参数值在0和1.0之间。 setOpacityMask (QBrush mask) //设置部分透明效果使用该类例子如下:QGraphicsOpacityEffect *e3 = new QGraphicsOpacityEffect(this); e3->setOpacity(0.7); item[3]->setGraphicsEffect(e3); -------- # QAbstractAnimation(动画) ![](Qt动画效果，特效实现QPropertyAnimation，QGraphicsEffect\2017-05-23-13-59-27.png) 动画框架由基类**QAbstractAnimation**和它的两个儿子*QVariantAnimation*和*QAnimationGroup*组成。**QAbstractAnimation**是所有动画类的祖宗。它包含了所有动画的基本属性。比如开始，停止和暂停一个动画的能力。它也可以接收时间改变通知。 动画框架又进一步提供了***QProertyAnimation***类。它继承自**QVariantAnimation**并对某个Qt属性（它须是Qt的”元数据对象系统”的一部分）执行动画。此类对属性执行一个宽松曲线插值。所以当你想去动画一个值时，你可以把它声明为一个属性，并且让你的类成为一个QObject。这给予我们极大的自由度来动画那些已存在的widget和其它QObject。 复杂的动画可以通过建立一个**QAbstractAnimation**的树来构建。这个树通过使用QAnimationGroups来创建，QAnimationGroups作为其它动画的容器。注意动画组也是从QAbstractAnimation派生的，所以动画组可以再包含其它动画组。 动画框架可以单独使用，同时也被设计为状态机框架的一部分。状态机提供了一个特定的状态可以用来播放动画。在进入或退出某个状态时QState也可以设置属性们，并且这个特定的动画状态将在指定QPropertyAnimation时给予的值之间做插值运算。后面我们要进一步介绍此问题。 在场景的背后，动画被一个全局定时器收集，这个定时器发送update到所有的正在播放的动画中。 * QAbstractAnimation 所有动画类的基类 * QAnimationGroup 动画组的基类 * QEasingCurve 控制动画的宽松曲线类 * QParallelAnimationGroup 并行动画组类 * QPauseAnimation 串行动画组类的暂停类 * QPropertyAnimation 动画Qt属性的类 * QSequentialAnimationGroup 串行动画组类 * QTimeLine 控制动画的时间线类 * QVariantAnimation 各动画类的虚基类 ## QPropertyAnimation 如前面所讲，QPropertyAnimation类可以修改Qt属性们。要动画一个值，就需要使用此类。实际上，它的父类，QVariantAnimation，是一个虚拟类，不能被直接使用。 1. 我们选择动画Qt属性的一个主要理由是Qt属性为我们提供了自己动画已存在的类的自由度。尤其是QWidget类（我们也可以把它嵌入到一个QGraphicsView中）具有很多属性表示其bounds,colors等等。让我们看一个小例子： ```cpp QPushButton button(&quot;Animated Button&quot;); button.show(); QPropertyAnimation animation(&amp;button, &quot;geometry&quot;); animation.setDuration(10000); animation.setStartValue(QRect(0, 0, 0, 0)); animation.setEndValue(QRect(250, 250, 100, 30)); animation.start(); 这段代码将把按钮在10秒种内从屏幕的左上角移动到(250,250)处，而且是逐渐变大。见下图效果： ![](Qt动画效果，特效实现QPropertyAnimation，QGraphicsEffect\1.gif) 上面的例子举在开始值和结束值之间做线性插值。还可以在开始和结束值之间设置值，插值运算就会经过这些点。 animation1 = new QPropertyAnimation(ui.pushButton, "geometry"); animation1->setDuration(10000); animation1->setKeyValueAt(0, QRect(0, 0, 00, 00)); animation1->setKeyValueAt(0.4, QRect(20, 250, 20, 30)); animation1->setKeyValueAt(0.8, QRect(100, 250, 20, 30)); animation1->setKeyValueAt(1, QRect(250, 250, 100, 30)); animation1->setEndValue(QRect(250, 250, 100, 30)); 在此例中，动画将按钮在8秒中内弄到(250,250)处，然后在2秒种内又弄回原位。移位是在这些点中间以线性插值进行的。 你也有可能动画一个QObject的值，虽然这些值并没有被声明为Qt属性。唯一的要求就是这个值具有一个setter。之后你可以从这个类派生子类从而包含这些值并且声明一个使用这个setter的属性。注意每个Qt属性都需要有一个getter，所以你需要提供一个getter，如果它不存在的话。 class MyGraphicsRectItem : public QObject, public QGraphicsRectItem{ Q_OBJECT Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry) }; 在上例中，我们派生了QGraphicsRectItem并定义了一个geometry属性。我们现在可以动画这个widget的geometry了，即使QGraphicsRectItem没有提供geometry属性。 QEasingCurveQPropertyAnimation在属性的开始值和结束值之间执行一个插值运算。除了向动画添加更多的关键值外，你还可以使用一个宽松曲线。宽松曲线描述了一个在0和1之间插值的速度变化的函数，如果你想控制一个动画的速度而不改变插值的路径时，就非常有用。 animation1 = new QPropertyAnimation(ui.pushButton, "geometry"); animation1->setDuration(10000); animation1->setStartValue(QRect(0, 0, 0, 0)); animation1->setEndValue(QRect(250, 250, 100, 30)); animation1->setEasingCurve(QEasingCurve::OutBounce); 这里，动画将按照一个曲线进行，这个曲线使得动画像一个跳动的皮球从开始位置跳到结束位置。QEasingCurve具有一个大曲线集合，你可以从里面选择一个。它们被定义为QEasingCurve::Type枚举。如果你需要不一样的曲线，你也可以自己实现一个，然后注册到QEasingCurve。 QAnimationGroup一个应用通常将包含不止一个动画。例如，你可能想同时移动多个图形item也可能顺序的一个接一个的移动。QanimationGroup的子类们(QSequentialAnimationGroup和QParallelAnimationGroup)是其它动画的容器，所以这些动画既可以并行也可以串行。QAnimationGroup是一个非属性动画的例子，但是它定期的收到时间改变的通知。这使得它可以把时间改变传输给所包含的动画们，从而控制何时播放那些动画们。 让我们看一下使用QParallelAnimationGroup和QSequentialAnimatoinGroup的代码示例。 QParallelAnimationGroup QPushButton *bonnie = new QPushButton("Bonnie"); bonnie->show(); QPushButton *clyde = new QPushButton("Clyde"); clyde->show(); QPropertyAnimation *anim1 = new QPropertyAnimation(bonnie, "geometry"); // Set up anim1 QPropertyAnimation *anim2 = new QPropertyAnimation(clyde, "geometry"); // Set up anim2 QParallelAnimationGroup *group = new QParallelAnimationGroup; group->addAnimation(anim1); group->addAnimation(anim2); group->start(); QParallelAnimationGroup* 并行在同一时刻播放group中的动画。对start()的调用将启动它所统治的所有的动画。 QsequentialAnimationGroup QPushButton button("Animated Button"); button.show(); QPropertyAnimation anim1(&amp;button, "geometry"); anim1.setDuration(3000); anim1.setStartValue(QRect(0, 0, 100, 30)); anim1.setEndValue(QRect(500, 500, 100, 30)); QPropertyAnimation anim2(&amp;button, "geometry"); anim2.setDuration(3000); anim2.setStartValue(QRect(500, 500, 100, 30)); anim2.setEndValue(QRect(1000, 500, 100, 30)); QSequentialAnimationGroup group; group.addAnimation(&amp;anim1); group.addAnimation(&amp;anim2); group.start(); QsequentialAnimationGroup** 顺序的播放它的动画们。它在上一个完成时按顺序播放下一个。 既然一个动画组本就是一个动画类，你可以把它添加到其它组中。如此，你可以建立起一个动画树。 动画和状态 当使用状态机，我们可以使用一个QSignalTransition或QEventTransition类在状态转换时连接一个或多个动画。这些类都是从QAbstractTransition派生的，它们定义了简易的函数addAnimation()，使得能够添加一个或多个动画，在状态转换时启动这些动画。 我们还可能连接属性与状态，而不是手动设置开始与结束值。下面是完整的代码，演示了动画一个QPushButton的geometry属性。 QPushButton *button = new QPushButton("Animated Button"); button->show(); QStateMachine *machine = new QStateMachine; QState *state1 = new QState(machine); state1->assignProperty(button, "geometry", QRect(0, 0, 100, 30)); machine->setInitialState(state1); QState *state2 = new QState(machine); state2->assignProperty(button, "geometry", QRect(250, 250, 100, 30)); QSignalTransition *transition1 = state1->addTransition(button, SIGNAL(clicked()), state2); transition1->addAnimation(new QPropertyAnimation(button, "geometry")); QSignalTransition *transition2 = state2->addTransition(button, SIGNAL(clicked()), state1); transition2->addAnimation(new QPropertyAnimation(button, "geometry")); machine->start();]]></content>
      <tags>
        <tag>qt</tag>
        <tag>c++</tag>
        <tag>动画</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QT窗口尺寸]]></title>
    <url>%2F2017%2F05%2F23%2FQT%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8%2F</url>
    <content type="text"><![CDATA[这一幅图可以清晰的展示qt窗口函数的关系 来源：http://blog.csdn.net/dbzhang800/article/details/6741344?reload 详解 frameGeometry()几何尺寸(位置+大小)对于窗口，包含窗口装饰器x()、y() pos()只包含位置信息(左上角坐标) move()只移动位置geometry() 几何尺寸(位置+大小)不包含窗口装饰器width()、height() rect()、size()只包含大小信息 setGeometry()改变位置+大小 resize()只改变大小]]></content>
      <tags>
        <tag>qt</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1SPAN最简曲面攻略]]></title>
    <url>%2F2017%2F05%2F22%2F1SPAN%E6%9C%80%E7%AE%80%E6%9B%B2%E9%9D%A2%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[这是以前学习犀牛建模软件时候对节点的总结，但凡曲面建模都是和节点分不开的。 什么是最简？控制点=阶数+1 这样的曲线叫做最简曲线，也就是说3阶4点，4阶5点，这样的曲线没有通过节点来增加额外的控制点，也是最完美最光滑的曲线。 什么是节点？犀牛的一些教学视频貌似很少提到这个节点，只有控制点或者内插控制点，节点好处就是阶数不变的情况下增加曲线的控制点，坏处就是增加的曲线的复杂程度，而且在曲线节点处只能达到G2连续，换句话说节点就是把2个3阶4点的曲线通过一个G2的连续组成一个3阶5点的曲线。这样的曲线就有2个跨距。 什么是跨距？如图，是一条3阶5点的曲线，那么红色标出来的位置就是节点。 起点或者终点或者节点到节点的位置，称为跨距（SPAN），3阶5点的曲线就是2SPAN。 下面再来详细讲一讲怎么查看犀牛里的节点，貌似是不能直接查看，那么查看的方式也比较简单，如图， 在点的编辑里点击插入节点，那么曲线上就会出现节点所在的位置了，图里的曲线3阶7点，3阶本来只有4个点，应为有3个节点的支持，使它变成7个控制点，再数数节点与节点之间的跨距，也就是4SPAN。 如何绘制最间曲线？最好是在画曲线的时候，心中就应该有一个数，应该是几个点能完成，那么在画曲线的时候在命令栏输入相应的阶数来完成点数的控制，再比如你如果想在2个曲线中间做一条过渡曲线那怎么画？这里大家应该都知道保持G1连续 需要2个控制点与上一个曲线保持在同一条线上，G2则是3个。如果在2个曲线间做一个过渡的最简线，那么G1则需要3阶4点，G2则需要5阶6点。 再绘制完曲线发现控制点不够怎么办？一般最常用的大家可能会想到打开点的编辑里面的添加控制点或者节点，在这里我不推荐这种方式，因为会增加曲线的SPAN，我介绍的方法是在SPAN保持为1的情况加增加控制点，那么可能会联想到重建曲线，点数比阶数大1点不就好了，没错，这是一个方法。但是重建过的曲线变动会比较大，远远达不到我所想要的效果，在这里我推荐用的是DEG，更改阶数。 在曲线工具菜单下的DEG。可以再曲线几乎不改变的情况下增大阶数，提供更多的控制点。当然这个工具虽好，但是不建议大家超过7阶，尽量把曲线控制在8点内完成。这个方法同样适用于曲面，曲面菜单里一样有一个DEG。大家不妨试试。 能做1SPAN的成面工具有哪些？这里常用的推荐大家3个，放样，双轨扫掠里的最间扫掠，还有以2,3,4条边缘建立曲面工具，这3个工具做出来的曲面质量比较好，在线没问题的情况下 都能轻松完成1SPAN曲面构建，1SPAN的构建除了工具要使用得当，曲线也很重要，。相同方向的2条曲线属性要相同，如图，一个方向是3阶4点。一个方向的是2阶3点，那么用边缘成面的工具自然是1SPAN，当然用双轨最间扫掠也能完成这个 那如果我把其中一个3阶4点改为3阶5点呢？ 用边缘建面工具做出来的一样是1SPAN，他会用4阶5点的边缘来逼近3阶4点的那条边，以保持同方向的属性都为5点，所以这个工具做1SPAN很常用，平时自然用的很少，虽然曲线属性不同，但是他会在自动逼近另一条属性不同的线，不过逼近的毕竟是有公差所以大家最好保持曲线同方向的属性相同， 这种情况用双轨如果选错轨道是勾选不了最间扫掠的，你选择2个属性不同的线做轨道是构线不了最间的。选择相同属性的2个线做轨道就可以勾选最间，效果同上一个工具。做1SPAN合理的分面也是相当重要，很多复杂的曲面是不可能用一个1SPAN就能做出来的，例如这样的过渡圆角， 这样的曲面是没法用一个1SPAN做出来的，那么就要分面。下部分由8个曲面组成。那么我们就分8个1SPAN来构建这个过渡曲面，，这样曲面的ISO等参线会不会更好看呢？ ISO线跟节点的关系所谓ISO线，在犀牛里叫做结构线，ALIAS里叫做等参线，它其实就是曲面中的节点，ISO所在的位置也就是曲线上节点所在的位置，如果这样说起来，UV方向 3阶4点的曲线是不存在ISO线的，3阶5点的曲面会在UV方向各有一根ISO线，这也是很多入门教程里说的犀牛里ISO线越少曲面越光滑的原因。因为节点更少。SPAN更少。细心的同学也发现 犀牛里3阶4点的曲面为什么也有一条ISO线呢。理论上确实不应该有，但是为了更好的查看曲面的趋势，所以才有这一根虚拟的ISO作为参考。 非4边面如何构建？曲面建模一般都是用合理的4边面来构建，为什么要这样做？我们首先画个3角面 开启他的控制点看看，只有一条边的控制点在三角形的边上，另外的2个都不在，这种图形也是被默认为4边面通过修剪得来的，那么在犀牛里修剪的边缘非常不好，不能匹配不能合并不能延伸，与修建边缘进行匹配的曲面只会无限的逼近那个边缘，公差越小逼近的曲面ISO则越多，曲面质量越差，这不是我们想要的结果，但是难免会出现一些3边面，5边面等，那么我改如何来构建？下图给你们答案。 把所有的多边形拆分为若干个1SPAN的4边面来做就好了，这样的面匹配起来可以不存在公差，结构线也整齐，互相贯穿，无非是多花点时间罢了。]]></content>
      <tags>
        <tag>犀牛</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇见c++匿名函数（lambda）]]></title>
    <url>%2F2017%2F05%2F22%2F%E9%81%87%E8%A7%81c%2B%2B%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88lambda%EF%BC%89%2F</url>
    <content type="text"><![CDATA[c++ 11新特性，匿名函数。。。 生成随机数字假设我们有一个vector&lt;int&gt;容器，想用100以内的随机数初始化它，其中一个办法是通过generate函数生成，如代码1所示。generate函数接受三个参数，前两个参数指定容器的起止位置，后一个参数指定生成逻辑，这个逻辑正是通过Lambda来表达的。 代码 1 我们现在看到Lambda是最简形式，只包含捕获子句和函数体两个必要部分，其他部分都省略了。[ ]是Lambda的捕获子句，也是引出Lambda的语法，当编译器看到这个符号时，就知道我们在写一个Lambda了。函数体通过{ }包围起来，里面的代码和一个普通函数的函数体没有什么不同。那么，代码1生成的随机数字里有多少个奇数呢，我们可以通过for_each函数数一下，如代码3所示。和generate函数不同的是，for_each函数要求我们提供的Lambda接受一个参数。一般情况下，如果Lambda的参数列表不包含任何参数，我们可以把它省略，就像代码1所示的那样；如果包含多个参数，可以通过逗号分隔，如(int index, std::string item)。 代码 2 看到这里，细心的读者可能已经发现代码2的捕获子句里面多了一个&quot;&amp;odd_count&quot;，这是用来干嘛的呢？我们知道，这个代码的关键部分是在Lambda的函数体里修改一个外部的计数变量，常见的语言（如C#）会自动为Lambda捕获当前上下文的所有变量，但C++要求我们在Lambda的捕获子句里显式指定想要捕获的变量，否则无法在函数体里使用这些变量。如果捕获子句里面什么都不写，像代码1所示的那样，编译器会认为我们不需要捕获任何变量。 除了显式指定想要捕获的变量，C++还要求我们指定这些变量的传递方式，可以选择的传递方式有两种：按值传递和按引用传递。像[&amp;odd_count]这种写法是按引用传递，这种传递方式使得你可以在Lambda的函数体里对odd_count变量进行修改。相对的，如果变量名字前面没有加上”&amp;”就是按值传递，这些变量在Lambda的函数体里是只读的。 如果你希望按引用传递捕获当前上下文的所有变量，可以把捕获子句写成[&amp;]；如果你希望按值传递捕获当前上下文的所有变量，可以把捕获子句写成[=]。如果你希望把按引用传递设为默认的传递方式，同时指定个别变量按值传递，可以把捕获子句写成[&amp;, a, b]；同理；如果默认的传递方式是按值传递，个别变量按引用传递，可以把捕获子句写成[=, &amp;a, &amp;b]。值得提醒的是，像[&amp;, a, &amp;b]和[=, &amp;a, b]这些写法是无效的，因为默认的传递方式均已覆盖b变量，无需单独指定，有效的写法应该是[&amp;, a]和[=, &amp;a]。 生成等差数列现在我们把一开始的问题改一下，通过generate函数生成一个首项为0，公差为2的等差数列。有了前面关于捕获子句的知识，我们很容易想到代码3这个方案，首先按引用传递捕获i变量，然后在Lambda的函数体里修改它的值，并返回给generate函数。 代码 3 如果我们把i变量的传递方式改成按值传递，然后在捕获子句后面加上mutable声明，如代码4所示，我们可以得到相同的效果，我指的是输出结果。那么，这两个方案有什么不一样呢？调用generate函数之后检查一下i变量的值就会找到答案了。需要说明的是，如果我们加上mutable声明，参数列表就不能省略了，即使里面没有包含任何参数。 代码 4 使用代码3这个方案，i变量的值在调用generate函数之后是18，而使用代码4这个方案，i变量的值是-2。这个意味着mutable声明使得我们可以在Lambda的函数体修改按值传递的变量，但这些修改对Lambda以外的世界是不可见的，有趣的是，这些修改在Lambda的多次调用之间是共享的。换句话说，代码4的generate函数调用了10次Lambda，前一次调用时对i变量的修改结果可以在后一次调用时访问得到。 这听起来就像有个对象，i变量是它的成员字段，而Lambda则是它的成员函数，事实上，Lambda是函数对象（Function Object）的语法糖，代码4的Lambda最终会被转换成代码5所示的Functor类。 代码 5 你也可以把代码4的Lambda替换成Functor类，如代码6所示。 代码 6 如何声明Lambda的类型？到目前为止，我们都是把Lambda作为参数直接传给函数的，如果我们想把一个Lambda传给多个函数，或者把它当作一个函数多次调用，那么就得考虑把它存到一个变量里了，问题是这个变量应该如何声明呢？如果你确实不知道，也不想知道，那么最简单的办法就是交给编译器处理，如代码7所示，这里的auto关键字相当于C#的var，编译器会根据我们用来初始化f1变量的值推断它的实际类型，这个过程是静态的，在编译时完成。 代码 7 如果我们想定义一个接受代码7的Lambda作为参数的函数，那么这个参数的类型又该如何写呢？我们可以把它声明为function模板类型，如代码8所示，里面的类型参数反映了Lambda的签名——两个int参数，一个int返回值。 代码 8 此外，你也可以把这个函数声明为模板函数，如代码9所示。 代码 9 无论你如何声明这个函数，调用的时候都是一样的，而且它们都能接受Lambda或者函数对象作为参数，如代码10所示。 代码 10 捕获变量的值什么时候确定？现在，我要把代码7的Lambda调整成代码11所示的那样，通过捕获子句而不是参数列表提供输入，这两个参数分别使用不同的传递方式，那么，我在第三行修改这两个参数的值会否对第四行的调用产生影响？ 代码 11 如果你运行代码11，你将会看到输出结果是5。为什么？这是因为按值传递在声明Lambda的那一刻就已经确定变量的值了，无论之后外面怎么修改，里面只能访问到声明时传过来的版本；而按引用传递则刚好相反，里面和外面看到的是同一个东西，因此在调用Lambda之前外面的任何修改对里面都是可见的。这种问题在C#里是没有的，因为C#只有按引用传递这种方式。 返回值的类型什么时候可以省略？最后，我们一直没有提到返回值的类型，编译器会一直帮我们自动推断吗？不会，只有两种情况可以在声明Lambda时省略返回值类型，而前面的例子刚好都满足这两种情况，因此推到现在才说： 函数体只包含一条返回语句，如最初的代码1所示。 Lambda没有返回值，如代码2所示。 当你需要加上返回值的类型时，必须把它放在参数列表后面，并且在返回值类型前面加上”-&gt;”符号，如代码12所示。 代码 12 以上代码均在Visual Studio 2010和Visual Studio 2012 RC上测试通过。]]></content>
      <tags>
        <tag>c++</tag>
        <tag>lambda</tag>
        <tag>匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++类型转换]]></title>
    <url>%2F2017%2F05%2F22%2Fc%2B%2B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2中类型转换: 隐式类型转换 强制类型转换 隐式类型转换提升精度此种是编译器自动完成的,安全的.所以编译的时候不会有任何错误或者警告信息提示. 示例: int ival = 3; double dval = 3.14159; // ival 被提升为 double 类型: 3.0 ival + dval; 降低精度也是有编译器自动完成,会造成精度丢失,所以编译时得到一个警告信息提示. 示例: double dval = 3.14159; // dval的值被截取为 int 值3 int ival = dval; 显式类型转换C风格的强制转换(包括旧式C++风格的强制转换)格式: *类型(表达式) ; *// 旧的C++风格或者(类型)表达式 ; // C风格 *示例: *int(dval) ;或者(int)dval ; 此种强制转换是比较粗暴直接的,有可能导致精度丢失(如从 double 转换为 int)或者一些莫名其妙的错误(如把 int 转换为 函数指针),一旦使用了强制转换,编译器将不提示任何警告.这也往往成为错误的源泉.而且这种错误非常难找.我想这也是C++要使用新的强制转换操作符的原因之一吧. C++强制转换操作符C++增加了4个关键字用于强制类型转换: const_cast dynamic_cast static_cast reinterpret_cast const_cast用来移除 const,这个没什么好说的. dynamic_cast需要 RTTI 支持, 主要用于把基类指针转换为派生类指针.这里的基类指针其实是指向一个派生类实例,只是类型为基类.示例: // 前提假设: class B 由 class A 派生 A *ptrA = new class B; B *ptrB = dynamic_cast&lt;B*>(ptrA); static_caststatic_cast 运算符完成相关类型 之间的转换. 所谓”相关类型”指的是从逻辑上来说,多多少少还有那么一点联系的类型。比如从 double 到 int,我们知道它们之间还是有联系的,只是精度差异而已,使用 static_cast 就是告诉编译器:我知道会引起精度损失,但是我不在乎.又如从 void* 到 具体类型指针像 char,从语义上我们知道 void 可以是任意类型的指针,当然也有可能是 char* 型的指针,这就是所谓的”多多少少还有那么一点联系”的意思.又如从派生类层次中的上行转换(即从派生类指针到基类指针,因为是安全的,所以可以用隐式类型转换)或者下行转换(不安全,应该用 dynamic_cast 代替).对于static_cast操作符,如果需要截断,补齐或者指针偏移编译器都会自动完成.注意这一点,是和 reinterpret_cast 的一个根本区别. reinterpret_castreinterpret_cast 处理互不相关的类型之间的转换. “互不相关的类型”指的是两种完全不同的类型,如从整型到指针类型,或者从一个指针到另一个毫不相干的指针.示例: int ival = 1; double *dptr = reinterpret_cast&lt;double*>(ival); 或者 int *iptr = NULL; double *dptr = reinterpret_cast&lt;double*>(iptr); reinterpret_cast 操作执行的是比特位拷贝,就好像用 memcpy() 一样. int *iptr = reinterpret_cast&lt;int*>(1); double *dptr = reinterpret_cast&lt;double*>(2); memcpy(&amp;dptr, &amp;iptr, sizeof(double*)); // 等效于 dptr = reinterpret_cast&lt;double*>(iptr); 结果 dptr 的值为1; 上面这个示例也说明了 reinterpret_cast 的意思:编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去.所以 reinterpret_cast 常常被用作不同类型指针间的相互转换,因为所有类型的指针的长度都是一致的(32位系统上都是4字节),按比特位拷贝后不会损失数据. 编程实践中几种典型的应用场景数值精度提示或者降低包括把无符号型转换为带符号型(也是精度损失的一种),用 static_cast 可以消除编译器的警告信息,前面提到好几次了. 任意类型指针到 void*隐式类型转换,自动完成. 看看 memcpy 的原型: void *memcpy( void *dest, const void *src, size_t count ); 参数定义为 void* 是有道理的,不管我们传入什么类型的指针都符合语义,并且不会有编译器警告. void* 到任意类型指针用 static_cast 和 reinterpret_cast 都可以,这是由 void* 是通用指针这个语义决定的.我个人倾向用 reinterpret_cast,表达要”重新解释”指针的语义. 不同类型指针间的相互转换用 reinterpret_cast. int 型和指针类型间的相互转换用 reinterpret_cast. 比如我写代码的时候经常这样做: new 一个 struct,然后把指针返回给外部函数作为一个”句柄”,我不希望外部函数知道这是一个指针,只需要外部函数在调用相关函数时把这个”句柄”重新传回来.这时,就可以把指针转换为一个 int 型返回. 这是 reinterpret_cast 存在的绝佳理由. struct car { int doors; int height; int length; float weight; }; int create_car() { car *c = new car; return reinterpret_cast&lt;int>(c); } int get_car_doors(int car_id) { car *c = reinterpret_cast&lt;car*>(car_id); return c->doors; } void destroy_car(int car_id) { car *c = reinterpret_cast&lt;car*>(car_id); delete c; } 如上,外部函数不需要知道 struct car 的具体定义,只需要调用 create_car() 得到一个 car id,然后用此 car_id 调用其他相关函数即可,至于 car_id 是什么,根本没必要关心. 派生类指针和基类指针间的相互转换 派生类指针到基类指针用隐式类型转换(直接赋值)或者用 static_cast. 显然不应该也没必要用 reinterpret_cast. 基类指针到派生类指针用 dynamic_cast (运行期检查)或者 static_cast (运行期不检查,由程序员保证正确性). 考虑到C++对象模型的内存分布可能引起的指针偏移问题,绝对不能用 reinterpret_cast. 后记几乎所有提到 reinterpret_cast 的书籍都要附带说什么”不可移植”,”危险”之类的词,好像 reinterpret_cast 是洪水猛兽,碰不得摸不得.其实理解了之后就知道没什么神秘的,存在即是理由,该用的时候就要大胆的用,否则C++保留这个关键字干什么? 关键是程序员应该清楚的知道自己要的结果是什么,如此,就是用C风格的强制转换又有何妨?]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中引用（&）的用法和应用实例]]></title>
    <url>%2F2017%2F05%2F22%2Fc%2B%2B%E4%B8%AD%E5%BC%95%E7%94%A8%EF%BC%88%26%EF%BC%89%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[对于习惯使用C进行开发的朋友们，在看到c++中出现的&amp;符号，可能会犯迷糊，因为在C语言中这个符号表示了取地址符，但是在C++中它却有着不同的用途，掌握C++的&amp;符号，是提高代码执行效率和增强代码质量的一个很好的办法。在 c++学习提高篇(3)—隐式指针的文章中我详细介绍了在隐式指针&amp;的用法，其实这两个概念是统一的。 引用是C++引入的新语言特性，是C++常用的一个重要内容之一，正确、灵活地使用引用，可以使程序简洁、高效。我在工作中发现，许多人使用它仅仅 是想当然，在某些微妙的场合，很容易出错，究其原由，大多因为没有搞清本源。故在本篇中我将对引用进行详细讨论，希望对大家更好地理解和使用引用起到抛砖 引玉的作用。 引用简介引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。 引用的声明方法：*&lt;类型标识符&gt; &amp;&lt;引用名&gt;=&lt;目标变量名&gt;；* 【例1】： int a; int &amp;ra=a; //定义引用ra,它是变量a的引用，即别名。 说明： &amp;在此不是求地址运算，而是起标识作用。 类型标识符是指目标变量的类型。 声明引用时，必须同时对其进行初始化。 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。 ra=1; 等价于 a=1; 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&amp;ra与&amp;a相等。 不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。 引用应用引用作为参数引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是”引用”。 【例2】： void swap(int &amp;p1, int &amp;p2) //此处函数的形参p1, p2都是引用 { int p; p=p1; p1=p2; p2=p; } 为在程序中调用该函数，则相应的主调函数的调用点处，直接 以变量作为实参 进行调用即可，而不需要实参变量有任何的特殊要求。如：对应上面定义的swap函数，相应的主调函数可写为： main( ) { int a,b; cin>>a>>b; //输入a,b两变量的值 swap(a,b); //直接以变量a和b作为实参调用swap函数 cout&lt;&lt;a&lt;&lt; ' ' &lt;&lt;b; //输出结果 } 上述程序运行时，如果输入数据10 20并回车后，则输出结果为20 10。 由【例2】可看出 结论： 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的 形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 常引用如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 常引用声明方式：const &lt;类型标识符&gt;&amp; &lt;引用名&gt;=&lt;目标变量名&gt;； 用这种方式声明的引用，不能通过引用对目标变量的值进行修改，从而使引用的目标成为const，达到了引用的安全性。 【例3】： int a ; const int &amp;ra=a; ra=1; //错误 a=1; //正确 这不光是让代码更健壮，也有些其它方面的需要。 【例4】： void bar(string &amp; s); bar("hello world"); //表达式是非法的 原因在于”hello world”串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。 正确的做法是： void bar(const string &amp; s); bar("hello world"); //表达式正确 相当于是当运行bar(&quot;hello world&quot;);的时候是声明了一个临时常量，比如const string temp=&quot;hello world&quot;;然后进行引用const string &amp; s=temp，这样就没有错了。 如果不把形参改成const，那么就应该在函数参数上这样做： void bar(string &amp; s); string a="hello world"; bar(a); //表达式正确 这个相当于是string&amp; s=a; a=&quot;hello world&quot;;这个是成立的。 引入概念： int a=10；左值 右值 如果函数参数导入的是右值，那么右值会产生一个临时对象，这个临时对象是const类型的。如果形参表示形式没有加上const，那么就是试图将一个const类型的对象转换为非const类型，这是非法的。 如果函数参数导入的是左值，那么就相当于是把左值取个别名（这个别名就是形参的名字）到函数体中，这是允许的。 引用型参数（形参）应该在能被定义为const的情况下，尽量定义为const。 引用作为返回值要以引用返回函数值，则函数定义时要按以下格式： &lt;类型标识符&gt; &amp;&lt;函数名&gt;（&lt;形参&gt;）{&lt;函数体&gt;} 说明： 以引用返回函数值，定义函数时需要在函数名前加&amp; 。 用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。 【例5】以下程序中定义了一个普通的函数fn1（它用返回值的方法返回函数值），另外一个函数fn2，它以引用的方法返回函数值。 #include &lt;iostream.h> float temp; //定义全局变量temp float fn1(float r); //声明函数fn1 float &amp;fn2(float r); //声明函数fn2 float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值 { temp=(float)(r*r*3.14); return temp; } float &amp;fn2(float r) //定义函数fn2，它以引用方式返回函数值 { temp=(float)(r*r*3.14); return temp; } void main() //主函数 { float a=fn1(10.0); //第1种情况，系统生成要返回值的副本（即临时变量） float &amp;b=fn1(10.0); //第2种情况，可能会出错（不同 C++系统有不同规定） //不能从被调函数中返回一个临时变量或局部变量的引用 float c=fn2(10.0); //第3种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 float &amp;d=fn2(10.0); //第4种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 cout&lt;&lt;a&lt;&lt;c&lt;&lt;d; } 【例6】测试用返回引用的函数值作为赋值表达式的左值。 #include &lt;iostream.h> int &amp;put(int n); int vals[10]; int error=-1; void main() { put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; cout&lt;&lt;vals[0]; cout&lt;&lt;vals[9]; } int &amp;put(int n) { if (n>=0 &amp;&amp; n&lt;=9 ) return vals[n]; else { cout&lt;&lt;"subscript error"; return error; } } 引用作为返回值，必须遵守以下规则： 不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。 不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。 可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。 引用与一些操作符的重载： 流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一 个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这 就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。 在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一 个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。 引用和多态引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。 【例7】： class A; class B：public A{……}; B b; A &amp;Ref = b; // 用派生类对象初始化基类对象的引用 Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。 引用总结 在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。 用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。 引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。 使用引用的时机。流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++关键字static]]></title>
    <url>%2F2017%2F05%2F22%2Fc%2B%2B%E5%85%B3%E9%94%AE%E5%AD%97static%2F</url>
    <content type="text"><![CDATA[这个概念对于我来说实在是太太抽象了，主要是实在找不到它和全局变量在使用上的区别，反正就是带全局的不要用，感觉编程上也用不到什么全局的东西，特别是面对对象的，只需要在class中去“全局”就可以了。 面向过程静态全局变量VS全局变量 静态全局变量 全局变量 分配内存地址 全局数据区 全局数据区 初始化 如果不显式初始化，将被隐式初始化为0 随机，除非显式地初始化 作用域 本源文件,不能被其它文件所用,其它文件中可定义相同名字的变量且不会发生冲突 可以跨文件使用，但是要用extern 修饰 生命周期 始终驻留在全局数据区，直到程序运行结束 始终驻留在全局数据区，直到程序运行结束 静态局部变量VS局部变量定义：在 局部变量 前加上 static[关键字] 时，就定义了静态局部变量。 静态局部变量 局部变量 分配内存地址 全局数据区 栈内存 初始化 如果不显式初始化，将会被隐式初始化为0，以后的函数调用不再进行初始化 随机，除非显式地初始化 作用域 局部作用域，当定义它的函数或语句块结束时，其作用域随之结束 局部作用域，当定义它的函数或语句块结束时，其作用域随之结束 生命周期 始终驻留在全局数据区，直到程序运行结束 退出函数体，系统收回栈内存，局部变量失效 面向对象静态成员变量特点： 作用范围： 静态成员变量被当作是类的成员，所有类的对象共享访问。 静态成员变量只有一份，无论有多少个类对象。 静态成员变量不属于特定的类对象，在没有产生类对象时其作用域就可见，我们就可以操作它。 分配内存地址： 静态成员变量存储在全局数据区。 静态成员变量定义时要分配空间，所以不能在类中声明定义。在类外使用语句&lt;数据类型&gt; &lt;类名&gt;::&lt;静态成员变量名&gt;=&lt;值&gt; 权限： 静态成员变量和普通数据成员一样遵从public,protected,private访问规则。 如果静态成员变量的访问权限允许的话（即public的成员），可在程序中，引用静态数据成员 。语句&lt;类名&gt;::&lt;静态成员变量名&gt;或者&lt;类对象名&gt;::&lt;静态成员变量名&gt; 静态成员函数特点： 静态成员函数为类的全部而服务，不是为某一个类的具体对象服务。 静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。 静态成员函数不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态成员，它只能调用其余的静态成员。 静态成员函数可以在类中被任何成员函数调用。简单地说静态成员函数很被动。 总结： 出现在类体外的函数定义不能指定关键字static； 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 非静态成员函数可以任意地访问静态成员函数和静态数据成员； 静态成员函数不能访问非静态成员函数和非静态数据成员； 由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长； 调用静态成员函数，可以用成员访问操作符（.）和（-&gt;；）为一个类的对象或指向类对象的指针调用静态成员函数. 小贴士初始化和赋值在c++中 初始化和赋值在代码表现上是截然不同的。 初始化int a = 10; 初始化指的是把a最开始的那个值确定下来。 赋值int a; a = 10; 赋值指的是先把a声明出来，系统随便指定了一个值给a，然后再人为的去改变那个初始值。]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令手册]]></title>
    <url>%2F2017%2F05%2F22%2Fgit%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[git 代码常用命令 创建新仓库(init)仓库创建新文件夹，打开，然后执行git init以创建新的 git 仓库。 裸仓库自己搭git server 我们基本都是创建裸仓库: cd ~ mkdir init.git cd init.git git init --bare 检出仓库(clone)执行如下命令以创建一个本地仓库的克隆版本：git clone /path/to/repository如果是远端服务器上的仓库，你的命令会是这个样子：git clone username@host:/path/to/repository 工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。 添加与提交(add | commit)你可以计划改动（把它们添加到缓存区），使用如下命令：git add &lt;filename&gt;git add *这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：git commit -m &quot;代码提交信息&quot;现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动(push | remote)上传你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：git push origin master可以把 master 换成你想要推送的任何分支。 查看，添加，删除，重命名上传地址查看当前的远程服务器地址：git remote -v 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：git remote add origin &lt;server&gt; origin是上传的主机名，可以自定义 当上传地址需要删除的时候，我们运行：git remote rm &lt;主机名&gt; 当上传地址需要重命名的时候，我们运行：git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 分支(branch | checkout | push)分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“feature_x”的分支：git branch -b feature_x创建一个叫做“feature_x”的分支，并切换过去：git checkout -b feature_x切换回主分支：git checkout master再把新建的分支删掉：git branch -d feature_x除非你将分支推送到远端仓库，不然该分支就是 _不为他人所见的_：git push origin &lt;branch&gt;每次push都只能上传你仓库中的一个branch remote分支和local分支（拉取远程分支到本地）查看远程分支查看所有分支：git branch -a查看所有远程分支：git branch -r查看所有本地分支：git branch -l 拉取远程分支并创建本地分支 方法一：git checkout -b 本地分支名x origin/远程分支名x使用该方式会在本地新建分支x，并自动切换到该本地分支x。 方式二：git fetch origin 远程分支名x:本地分支名x使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。 更新与合并(pull | mrege | diff)要更新你的本地仓库至最新改动，执行：git pull等价于：git fetch+git merge以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：git merge &lt;branch&gt;两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）_。 这时候就需要你修改这些文件来人肉合并这些 _冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功：git add &lt;filename&gt;在合并改动之前，也可以使用如下命令查看：git diff &lt;source_branch&gt; &lt;target_branch&gt; 标签(tag)在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：git tag 1.0.0 1b2e1d63ff1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：git log你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。 替换本地改动(checkout | reset | revert)checkout假如你代码写错，但只是想恢复1个文件时，你可以使用如下命令替换掉本地改动：git checkout -- &lt;filename&gt;git checkout -- hello.rb这条命令把hello.rb从HEAD中签出并且把它恢复成未修改时的样子.这个只是恢复一个文件，如果全部要恢复就要使用git reset 或者是git revert。 reset这种情况发生在你的本地代码仓库,可能你add ,commit 以后发现代码有点问题,准备取消提交,用到下面命令： git reset [--soft | --mixed | --hard ] 上面常见三种类型： –mixed工作区不变,只是将commit 和index 信息回退到了某个版本。 git reset *默认是 –mixed 模式 * git reset --mixed 等价于 git reset 工作区不回退，但是index又回退了，这个要重新提交commit还要git add .之后才能提交，没–soft来得方便 –soft工作区不变,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可。这个有点像是删除commit节点，自己再重新提交commit。 –hard工作区回退到某个版本,commit 和index 都回回退到某个版本。(注意,这种方式是改变本地代 码仓库源码) 这个是最常用的 worning: reset只是改变本地的仓库，但使用时还是要谨慎，他会把你要恢复的commit之后的所有节点全部清除！如果节点删除错误可以使用git pull进行恢复！ 类型 工作区 index commit(节点) mixed X &radic; &radic; soft X X &radic; hard &radic; &radic; &radic; 回退：&radic; 不回退：X revertgit revert用一个新提交来消除一个历史提交所做的任何修改。revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新。(这里不会像reset造成冲突的问题)git revert 版本会递增，不影响之前提交的内容。 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同。 little tipsgit revert 和 git reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git revert 和 git reset回滚方法git reset --hard HEAD 重置到当前的 commitgit reset --hard HEAD~1 重置到当前指向的前一次 commitgit reset --hard &lt;commit&gt; （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）重置到指定的版本 git revert HEAD 撤销当前的 commit(工作区回到上一次的 commit)git revert HEAD~1 撤销当前的前一次 commit(工作区回到上上次的 commit)git revert &lt;commit&gt; 撤销指定版本(工作区回到指定版本上一次的 commit)]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git结构图]]></title>
    <url>%2F2017%2F05%2F21%2Fgit%E7%BB%93%E6%9E%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[从知乎上找到的一张图，便于理解git的branch管理]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[主题样式列表]]></title>
    <url>%2F2016%2F06%2F01%2F%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[标题1标题2标题3标题4标题5标题6code line improt test code bracket text print("hello world !") quote quote quote quote quotequote quote quote quotequote quote line1 line2 line3 line3 line3 line3line3 line4 line5]]></content>
      <tags>
        <tag>sheets</tag>
      </tags>
  </entry>
</search>
