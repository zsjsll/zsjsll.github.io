---
title: shell编程 ( )，(( ))，[ ]，[[ ]]，{ } 的作用
date: 2017-06-23 09:24:27
categories:
tags:
- shell
- linux
---

第一次接触linux下shell脚本进行数学运算完全摸不到头脑。本问介绍shell下如何进行运算，其中还扩展出了一些其他的东西。
<!--more-->

# shell的运算

在使用运算符时，需要注意到运算顺序的问题。例如输入下面的命令，输出1+2的结果。

```bash
echo 1+2
```

Shell并没有输出结果3，而是输出了1+2。在shell中有三种方法可以更改运算顺序。

* 用expr改变运算顺序。可以用**echo &apos;expr 1 +2&apos;** 来输出1+2的结果，用expr表示后面的表达式为一个数学运算。需要注意的是，&apos; 并不是一个单引号，而是“Tab”键上面的那个符号。

* 用let指示数学运算。可以先将运算的结果赋值给变量b，运算命令是b=let 1 + 2。然后用echo$b来输出b的值。如果没有let，则会输出1+2。

* 用$[ ]表示数学运算的值。将一个数学运算写到$[ ]符号的中括号中，中括号中的内容将先进行数学运算。例如命令echo $[1+2]，将输出结果3。也可以使用$(( ))。

## ( )

* 命令组：在括号中的命令列表, 将会作为一个**子shell**来运行。
在括号中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的。父进程，也就是脚本本身，将不能够读取在子进程中创建的变量，也就是在子shell中创建的变量。
`(cmd1;cmd2;cmd3)`

* 初始化数组
`Array=(element1 element2 element3)`
 
## (( ))

* (( ... ))结构可以用来计算并测试算术表达式的结果. 退出状态将会与[ ... ]结构完全相反！
还可应用到c风格的for，while循环语句，(( )) 中，所有的变量(加不加$无所谓)都是数值。
$((...))结构的表达式是C风格的表达式，其返回的结果是表达式值，其中变量引用可不用‘$’(当然也可以）。
```bash
for((...;...;...))
do
  cmd
done
```
```bash
while ((...))
do
  cmd
done
```

* 比较操作符
小于： 
`(($a < $b))`
小于等于：
`(($a <= $b))`
大于：
`(($a > $b))`
大于等于：
`(($a >= $b))`

_ps：如果要用echo输出出来，或者被其他变量调用，在前面要加$符号，比如 `echo $((...))` 。_

## [ ]

**注意空格：** 标识符，变量，运算符之间都是要有空格的！

* bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

* Test和[ ]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。

* 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。

* 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

## [[  ]]

**注意空格：** 标识符，变量，运算符之间都是要有空格的！

* [[ ]] 结构比[ ]结构更加通用。在[[ ]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

* 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。
例：
```bash
if [[ $a != 1 && $a != 2 ]]
```
如果不适用双括号，则为
```bash
if [ $a -ne 1] && [ $a != 2 ]
```
或者
```bash
if [ $a -ne 1 -a $a != 2 ]
```

_ps：[[ ]]比[ ] 更好用。但是[ ]可以进行算术运算比较，$[ ]可以返回数学表达式的值。_

## { }

* 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与( )中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。**{ }的第一个命令和左括号之间必须要有一个空格。**

* 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
    * 第一种：对大括号中的以逗号分割的文件列表进行拓展。
```bash
touch {a,b}.txt
```
结果为a.txt b.txt。

    * 第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用或者使用[ - ]。
```bash
touch {a..d}.txt
#等价于
touch [a-d].txt
``` 
结果为a.txt b.txt c.txt d.txt

* ${ } 它其实就是用来作变量替换用的。一般情况下，$var 与 ${var} 并没有啥不一样。但是用 ${ } 会比较精确的界定变量名称的范围。 
``` bash
#定义了变量为： 
file=/dir1/dir2/dir3/my.file.txt
```
1.我们可以用 ${ } 分别替换获得不同的值：
```bash
${file#*/}      拿掉第一条 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt
${file##*/}     拿掉最后一条 / 及其左边的字符串：my.file.txt
${file#*.}      拿掉第一个 . 及其左边的字符串：file.txt
${file##*.}     拿掉最后一个 . 及其左边的字符串：txt
${file%/*}      拿掉最后条 / 及其右边的字符串：/dir1/dir2/dir3
${file%%/*}     拿掉第一条 / 及其右边的字符串：(空值)
${file%.*}      拿掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file
${file%%.*}     拿掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 
``` 
记忆的方法为：
**#是去掉左边(在键盘上 # 在 $ 之左边)**
**%是去掉右边(在键盘上 % 在 $ 之右边)**
　　
2.单一符号是最小匹配﹔两个符号是最大匹配：
```bash
${file:0:5}     提取最左边的 5 个字节：/dir1
${file:5:5}     提取第 5 个字节右边的连续 5 个字节：/dir2 
```
3.我们也可以对变量值里的字符串作替换：
```bash
${file/dir/path}     将第一个 dir 提换为 path：/path1/dir2/dir3/my.file.txt
${file//dir/path}    将全部 dir 提换为 path：/path1/path2/path3/my.file.txt 
```
4.利用 ${ } 还可针对不同的变量状态赋值(没设定、空值、非空值)：
```bash
${file-my.file.txt}     假如 $file 没有设定，则使用 my.file.txt 作传回值。(空值及非空值时不作处理)
${file:-my.file.txt}    假如 $file 没有设定或为空值，则使用my.file.txt 作传回值。 (非空值时不作处理)
${file+my.file.txt}     假如 $file 设为空值或非空值，均使用my.file.txt 作传回值。(没设定时不作处理)
${file:+my.file.txt}    若 $file 为非空值，则使用 my.file.txt 作传回值。(没设定及空值时不作处理)
${file=my.file.txt}     若 $file 没设定，则使用 my.file.txt 作传回值，
                            同时将 $file 赋值为 my.file.txt 。(空值及非空值时不作处理)
${file:=my.file.txt}    若$file没设定或为空值，则使用my.file.txt作传回值，
                            同时将 $file 赋值为my.file.txt 。(非空值时不作处理)
${file?my.file.txt}     若 $file 没设定，则将 my.file.txt 输出至STDERR。(空值及非空值时不作处理)
${file:?my.file.txt}    若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。(非空值时不作处理)
```
以上的理解在于，你一定要分清楚 unset 与 null 及 non-null 这三种赋值状态。
一般而言：
`: 与 null 有关，若不带 : 的话，null 不受影响，若带 : 则连null 也受影响。`
　
5.可以用 ${<font>#</font>var} 计算出变量值的长度：  
```bash
${#file}        可得到 27 ，因为 /dir1/dir2/dir3/my.file.txt 刚好是 27 个字节... 
```


_ps:为了规范代码建议在使用变量时，统一用 { } 把变量包裹住。例如：${var}_

## 总结

()会开启一个新的子shell，{}不会开启一个新的子shell。

(())常用于算术运算比较,[[]]常用于字符串的比较。

$()返回括号中命令执行的结果。

$(())返回的结果是括号中表达式值。

$(())和$[]都可以进行数学运算且返回表达式的值。

${ }参数替换与扩展。